<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[React中文文档(二)Tutorial]]></title>
      <url>http://yoursite.com/2017/03/09/React%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3(%E4%BA%8C)/</url>
      <content type="html"><![CDATA[<p><img src="https://ooo.0o0.ooo/2017/03/08/58bf86c6ce2b1.jpg" alt="react"></p>
<p>本文翻译自<a href="http://reactjs.cn/react/docs/tutorial.html" target="_blank" rel="external">React官网教程</a>,欢迎指出错误。<br><a id="more"></a></p>
<p>我们将构造一个简单却真实的可被直接放进博客里使用的评论框，一个由Disqus, LiveFyre或Facebook comments提供的实时评论的基础版本。<br>我们将提供</p>
<ul>
<li>一个所有评论的视图</li>
<li>一个提交评论的表单</li>
<li><strong><em>Hooks for you to provide a custom backend</em></strong></li>
</ul>
<p>它同时也有一些简单的功能：</p>
<ul>
<li>优化的评论功能：评论内容在它们被存储到服务器之前就在列表里显示，所以感觉很快。</li>
<li>实时更新：其他用户的评论会被实时显示在评论框</li>
<li>Mardown格式化：用户能用Markdown格式化文档</li>
</ul>
<h2 id="想跳过步骤直接去看源码吗？"><a href="#想跳过步骤直接去看源码吗？" class="headerlink" title="想跳过步骤直接去看源码吗？"></a>想跳过步骤直接去看源码吗？</h2><p><a href="https://github.com/reactjs/react-tutorial" target="_blank" rel="external">代码地址</a></p>
<h2 id="运行一个服务器"><a href="#运行一个服务器" class="headerlink" title="运行一个服务器"></a>运行一个服务器</h2><p>为了开始教程，我们需要一个运行的服务器。服务器仅被用来作为一个<strong><em>API endpoint</em></strong>来存取数据。为了使这步尽量简单，我们已经用不同脚本语言搭建了简单的服务器，正好完成我们需要的事。你可以<a href="https://github.com/reactjs/react-tutorial/" target="_blank" rel="external">查看源代码</a>或者<a href="https://github.com/reactjs/react-tutorial/archive/master.zip" target="_blank" rel="external">现在压缩包</a>，里面包含了你开始学习需要的所有东西。</p>
<p>简单起见，服务器会使用<code>JSON</code>文件作为数据库来运行。你不会在生产环境中使用它，但它简单模拟了你在运行API时会做的事。一旦你启动服务器，他会支持我们的API <strong><em>endpoint</em></strong>终端，同时<strong><em>serve*</em></strong>展示我们需要的静态页面。</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>对于此课程，我们将会尽量简单。我们上面提到的服务器包里有一个我们将会用到的<code>HTML</code>文件。在编辑器中打开<code>public/index.html</code>文件。内容如下<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- index.html --&gt;</span></div><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>React Tutorial<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://npmcdn.com/react@15.3.1/dist/react.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://npmcdn.com/react-dom@15.3.1/dist/react-dom.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://npmcdn.com/babel-core@5.8.38/browser.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://npmcdn.com/jquery@3.1.0/dist/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://npmcdn.com/remarkable@1.6.2/dist/remarkable.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span> <span class="attr">src</span>=<span class="string">"scripts/example.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span><span class="javascript"></span></div><div class="line">      <span class="comment">// To get started with this tutorial running your own code, simply remove</span></div><div class="line">      <span class="comment">// the script tag loading scripts/example.js and start writing code here.</span></div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>对于教程的剩余部分，我们将在script标签里写js代码。我们没有任何提前配置的实时更改设置，所以你需要在保存后刷新浏览器查看更新。通过在浏览器中打开<code>http://localhost:3000</code>来实时跟进你的进度（在运行服务器后）。当你不加更改第一次加载时，你将会看到我们即将建立的demo的最终版。当你准备好开工，只用删掉前面的<code>&lt;script&gt;</code>标签然后继续。</p>
<blockquote>
<p><strong>Note:</strong><br>我们在这里引入了jquery因为我们想简化我们未来的ajax请求，但这对于React来说不是必需的</p>
</blockquote>
<h2 id="你的第一个组件"><a href="#你的第一个组件" class="headerlink" title="你的第一个组件"></a>你的第一个组件</h2><p>React都是关于模块化，可组装的组件。对于我们例子的评论框，我们将按如下结构架构组件<br><br><img src="https://ooo.0o0.ooo/2017/03/09/58c164f69c0a0.png" style="width:50%"></p>
<pre><code>- CommentBox
  - CommentList
    - Comment
  - CommentForm
</code></pre><p>让我们来构造<code>CommentBox</code>组件，只是一个简单的<code>&lt;div&gt;</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// tutorial1.js</span></div><div class="line"><span class="keyword">var</span> CommentBox = React.createClass(&#123;</div><div class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"commentBox"</span>&gt;</span></span></div><div class="line">        Hello, world! I am a CommentBox.</div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">ReactDOM.render(</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">CommentBox</span> /&gt;</span>,</span></div><div class="line">  document.getElementById('content')</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>注意原生的html标签名都是以小写字母开头，而定义的React类名以大写字母开头</p>
<h3 id="JSX语法"><a href="#JSX语法" class="headerlink" title="JSX语法"></a>JSX语法</h3><p>首先你会注意到js文件里的类XML代码。我们有一个简单的预编译器来把它转换成js代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// tutorial1-raw.js</span></div><div class="line"><span class="keyword">var</span> CommentBox = React.createClass(&#123;displayName: <span class="string">'CommentBox'</span>,</div><div class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      React.createElement(<span class="string">'div'</span>, &#123;className: <span class="string">"commentBox"</span>&#125;,</div><div class="line">        <span class="string">"Hello, world! I am a CommentBox."</span></div><div class="line">      )</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">ReactDOM.render(</div><div class="line">  React.createElement(CommentBox, <span class="literal">null</span>),</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>)</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>你可以选择是否用jsx，但我们发现它比纯js代码更易使用。阅读更多<a href="">JSX语法</a></p>
<h3 id="发生了什么"><a href="#发生了什么" class="headerlink" title="发生了什么"></a>发生了什么</h3><p>我们在一个javascript对象中传递了一些方法给<code>React.createClass()</code>，来新建一个React组件。最重要的方法是<code>render</code>，它返回一颗React组件树，被用来最终渲染成html。</p>
<p>这些<div>标签并不是真实的DOM节点，它们是React<code>div</code>组件的实例。你可以将这些看成React知道如何处理的标记或数据。React是安全的。我们不生成HTML字符串，所以XSS防护是默认的。</div></p>
<p>你不是必须返回基本的HTML。你可以返回你（或其他人）建造的组件树。这就是React组件化的原因：一个可维护的前端的基本原则。</p>
<p><code>ReactDOM.render()</code>实例化根组件，启动框架，注入标记到原始的DOM元素，作为第二参数提供。</p>
<p>ReactDOM模块暴露指定DOM的方法，React拥有不同平台的React（比如React Native）分享的核心工具</p>
<p>在本教程中，<code>ReactDOM.render</code>位于script文件的底端十分重要，<code>ReactDOM.render</code>只能在复合组件都被定义好后才能被调用。</p>
<h2 id="组合组件"><a href="#组合组件" class="headerlink" title="组合组件"></a>组合组件</h2><p>让我们来为<code>CommentList</code>和<code>CommentForm</code>进行架构，同样也是些简单的<code>&lt;div&gt;</code>标签。把这两个组件加进你的文件，保留原来就存在的<code>CommentBox</code>声明和<code>ReactDOM.render</code>调用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// tutorial2.js</span></div><div class="line"><span class="keyword">var</span> CommentList = React.createClass(&#123;</div><div class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"commentList"</span>&gt;</span></span></div><div class="line">        Hello, world! I am a CommentList.</div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> CommentForm = React.createClass(&#123;</div><div class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"commentForm"</span>&gt;</span></span></div><div class="line">        Hello, world! I am a CommentForm.</div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>接下来使用这些新组件来更新<code>CommentBox</code>组件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// tutorial3.js</span></div><div class="line"><span class="keyword">var</span> CommentBox = React.createClass(&#123;</div><div class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"commentBox"</span>&gt;</span></span></div><div class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Comments<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">CommentList</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">CommentForm</span> /&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>注意我们是如何混合 HTML 标签和我们建立的组件的。HTML组件是正常的React组件，就你定义的那些，只有一个区别。JSX编译器会自动重写HTML标签为React.createElement(tagName)表达式，其他都不变。这是为了避免污染全局命名空间。</p>
<h3 id="使用props属性"><a href="#使用props属性" class="headerlink" title="使用props属性"></a>使用props属性</h3><p>现在我们来创建<code>Comment</code>组件，它会依赖于从父节点传来的数据。从父组件传来的数据可以作为<code>property</code>在子组件中使用。这些<code>properties</code>通过<code>this.props</code>传入。使用props，我们能读取到从<code>CommentList</code>传到<code>Comment</code>的数据，并且渲染一些标记<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// tutorial4.js</span></div><div class="line"><span class="keyword">var</span> Comment = React.createClass(&#123;</div><div class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"comment"</span>&gt;</span></span></div><div class="line">        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">className</span>=<span class="string">"commentAuthor"</span>&gt;</span></div><div class="line">          &#123;this.props.author&#125;</div><div class="line">        <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">        &#123;this.props.children&#125;</div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>在JSX中，通过把js表达式放在大括号中（作为属性或者子节点），你能在树中添加文本或React组件。我们通过<code>this.props</code>的keys访问传递给组件的命名属性，通过<code>this.props.children</code>访问其他嵌套的元素。</p>
<h2 id="组件特性"><a href="#组件特性" class="headerlink" title="组件特性"></a>组件特性</h2><p>现在我们已经定义了<code>Comment</code>组件，我们想给他传作者名和评论文本。这允许我们对每个评论重用相同的代码。现在让我们在<code>CommentList</code>里来加一些评论：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// tutorial5.js</span></div><div class="line"><span class="keyword">var</span> CommentList = React.createClass(&#123;</div><div class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"commentList"</span>&gt;</span></span></div><div class="line">        <span class="tag">&lt;<span class="name">Comment</span> <span class="attr">author</span>=<span class="string">"Pete Hunt"</span>&gt;</span>This is one comment<span class="tag">&lt;/<span class="name">Comment</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">Comment</span> <span class="attr">author</span>=<span class="string">"Jordan Walke"</span>&gt;</span>This is *another* comment<span class="tag">&lt;/<span class="name">Comment</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>注意到我们从父组件<code>CommentList</code>给子组件<code>Comment</code>传递了一些数据。比如，我们传递了<em>Pete Hunt</em>(通过一个属性)，传递了<em>This is one comment</em>（通过一个类xml子节点）给第一个<code>Comment</code>。正如上面提到的，<code>Comment</code>组件将会通过<code>this.props.author</code>和<code>this.prps.children</code>来接受这些‘属性’。</p>
<h2 id="添加Markdown"><a href="#添加Markdown" class="headerlink" title="添加Markdown"></a>添加Markdown</h2><p>Markdown是一种格式化内联文本的简单方法。比如，用星号包围的文本会变成斜体。</p>
<p>在这个教程中，我们使用第三方库<code>remarkable</code>来把markdown文本转换成原始html。我们已经在页面的最初标签包含了这个库，所以我们能直接开始使用它。让我们把评论文本转化成markdown并且输出它。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// tutorial6.js</span></div><div class="line"><span class="keyword">var</span> Comment = React.createClass(&#123;</div><div class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> md = <span class="keyword">new</span> Remarkable();</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"comment"</span>&gt;</span></span></div><div class="line">        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">className</span>=<span class="string">"commentAuthor"</span>&gt;</span></div><div class="line">          &#123;this.props.author&#125;</div><div class="line">        <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">        &#123;md.render(this.props.children.toString())&#125;</div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>我们需要做的只是调用remarkable库。我们需要把从react包裹的文本<code>this.props.children</code>转化成remarkable能识别的原始字符串，所以我们调用了<code>toString</code>方法。</p>
<p>但是也有一些问题！我们渲染过的评论在浏览器里显示为“<code>&lt;p&gt;</code>This is <code>&lt;em&gt;</code>another<code>&lt;/em&gt;</code> comment<code>&lt;/p&gt;</code>”，我们想让这些标签像html一样渲染。</p>
<p>这是react为了防范<a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="external">xss</a>攻击。有一种方法可以绕过它但是框架会警告你不要使用它。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// tutorial7.js</span></div><div class="line"><span class="keyword">var</span> Comment = React.createClass(&#123;</div><div class="line">  rawMarkup: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> md = <span class="keyword">new</span> Remarkable();</div><div class="line">    <span class="keyword">var</span> rawMarkup = md.render(<span class="keyword">this</span>.props.children.toString());</div><div class="line">    <span class="keyword">return</span> &#123; __html: rawMarkup &#125;;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"comment"</span>&gt;</span></span></div><div class="line">        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">className</span>=<span class="string">"commentAuthor"</span>&gt;</span></div><div class="line">          &#123;this.props.author&#125;</div><div class="line">        <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">dangerouslySetInnerHTML</span>=<span class="string">&#123;this.rawMarkup()&#125;</span> /&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这个特殊的API故意使插入原始html变得困难，但是对于remarkable我们将会利用这个特性。</p>
<p><strong>记住：</strong>通过使用这个功能，remarkable是安全的。所以，remarkable在输出中自动去除html标记和不安全的链接。</p>
<h2 id="连接数据模型"><a href="#连接数据模型" class="headerlink" title="连接数据模型"></a>连接数据模型</h2><p>到现在，我们都是直接在源代码里插入评论。换一种形式，让我们渲染一系列json数据到comment list。这些最终是要从服务器读取，但是现在，先把它写入源代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// tutorial8.js</span></div><div class="line"><span class="keyword">var</span> data = [</div><div class="line">  &#123;id: <span class="number">1</span>, author: <span class="string">"Pete Hunt"</span>, text: <span class="string">"This is one comment"</span>&#125;,</div><div class="line">  &#123;id: <span class="number">2</span>, author: <span class="string">"Jordan Walke"</span>, text: <span class="string">"This is *another* comment"</span>&#125;</div><div class="line">];</div></pre></td></tr></table></figure></p>
<p>我们需要以一个模块化的方法来从<code>CommentList</code>里得到数据。修改<code>CommentBox</code>和<code>ReactDOM.render()</code>调用来把这些数据通过props传到<code>CmomentList</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// tutorial9.js</span></div><div class="line"><span class="keyword">var</span> CommentBox = React.createClass(&#123;</div><div class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div className="commentBox"&gt;</div><div class="line">        &lt;h1&gt;Comments&lt;/h1&gt;</div><div class="line">        &lt;CommentList data=&#123;this.props.data&#125; /&gt;</div><div class="line">        &lt;CommentForm /&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">ReactDOM.render(</div><div class="line">  &lt;CommentBox data=&#123;data&#125; /&gt;,</div><div class="line">  document.getElementById('content')</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>既然这些数据在<code>CommentList</code>里是可利用的，让我们来动态的渲染评论：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// tutorial10.js</span></div><div class="line"><span class="keyword">var</span> CommentList = React.createClass(&#123;</div><div class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> commentNodes = <span class="keyword">this</span>.props.data.map(<span class="function"><span class="keyword">function</span>(<span class="params">comment</span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> (</div><div class="line">        <span class="xml"><span class="tag">&lt;<span class="name">Comment</span> <span class="attr">author</span>=<span class="string">&#123;comment.author&#125;</span> <span class="attr">key</span>=<span class="string">&#123;comment.id&#125;</span>&gt;</span></span></div><div class="line">          &#123;comment.text&#125;</div><div class="line">        <span class="tag">&lt;/<span class="name">Comment</span>&gt;</span></div><div class="line">      );</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"commentList"</span>&gt;</span></span></div><div class="line">        &#123;commentNodes&#125;</div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>就是这样！</p>
<h2 id="从服务器取得数据"><a href="#从服务器取得数据" class="headerlink" title="从服务器取得数据"></a>从服务器取得数据</h2><p>让我们来用一些从服务器取得的动态数据来替换这些硬编码数据。我们将移除data属性并且用一个URL替换来取数据：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// tutorial11.js</span></div><div class="line">ReactDOM.render(</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">CommentBox</span> <span class="attr">url</span>=<span class="string">"/api/comments"</span> /&gt;</span>,</span></div><div class="line">  document.getElementById('content')</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>这个组件不同于和前面的组件，因为它必须重新渲染自己。它在请求从服务器返回前不会有任何数据，此时这个组件或许需要渲染一些新的评论。</p>
<p>注意： 代码在这个阶段不会工作。</p>
<h2 id="reactive状态"><a href="#reactive状态" class="headerlink" title="reactive状态"></a>reactive状态</h2><p>到现在为止，基于它的props，每个组件都会渲染自身一次。props是不可改变的：它们由父组件传递并且属于父组件。为了实现交互，我们给组件引入了一个动态的<strong>状态</strong>。<code>this.state</code>是组件的私有变量并且通过调用<code>this.setState()</code>被改变。当状态更新时，组件便重新进行渲染。</p>
<p><code>render()</code>方法被声明为this.props和this.state的函数，框架保证UI始终与输入一致。</p>
<p>当从服务器获取数据时，我们会改变已有的评论数据。让我们向<code>CommentBox</code>组件添加一个评论数据数组作为它的state。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// tutorial12.js</span></div><div class="line"><span class="keyword">var</span> CommentBox = React.createClass(&#123;</div><div class="line">  getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;data: []&#125;;</div><div class="line">  &#125;,</div><div class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div className="commentBox"&gt;</div><div class="line">        &lt;h1&gt;Comments&lt;/h1&gt;</div><div class="line">        &lt;CommentList data=&#123;this.state.data&#125; /&gt;</div><div class="line">        &lt;CommentForm /&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>getInitialState()</code>在组件的生命周期里只执行一次，并且初始化组件状态。</p>
<h3 id="更新状态"><a href="#更新状态" class="headerlink" title="更新状态"></a>更新状态</h3><p>当这个组件第一次被创建，我们要从服务器<code>GET</code>一些<code>JSON</code>文件，并且更新状态来显示最近的数据。我们将使用jquery来给我们先前启动的服务器服务器发送异步请求来获取我们需要的数据。这个数据是早就包含在启动的服务器中的（基于<code>common.js</code>文件），所以，一旦它被获取，<code>this.state.data</code>会变成：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  &#123;<span class="string">"id"</span>: <span class="string">"1"</span>, <span class="string">"author"</span>: <span class="string">"Pete Hunt"</span>, <span class="string">"text"</span>: <span class="string">"This is one comment"</span>&#125;,</div><div class="line">  &#123;<span class="string">"id"</span>: <span class="string">"2"</span>, <span class="string">"author"</span>: <span class="string">"Jordan Walke"</span>, <span class="string">"text"</span>: <span class="string">"This is *another* comment"</span>&#125;</div><div class="line">]</div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// tutorial13.js</span></div><div class="line"><span class="keyword">var</span> CommentBox = React.createClass(&#123;</div><div class="line">  getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;data: []&#125;;</div><div class="line">  &#125;,</div><div class="line">  componentDidMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    $.ajax(&#123;</div><div class="line">      url: <span class="keyword">this</span>.props.url,</div><div class="line">      dataType: <span class="string">'json'</span>,</div><div class="line">      cache: <span class="literal">false</span>,</div><div class="line">      success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.setState(&#123;data: data&#125;);</div><div class="line">      &#125;.bind(<span class="keyword">this</span>),</div><div class="line">      error: <span class="function"><span class="keyword">function</span>(<span class="params">xhr, status, err</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.error(<span class="keyword">this</span>.props.url, status, err.toString());</div><div class="line">      &#125;.bind(<span class="keyword">this</span>)</div><div class="line">    &#125;);</div><div class="line">  &#125;,</div><div class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div className="commentBox"&gt;</div><div class="line">        &lt;h1&gt;Comments&lt;/h1&gt;</div><div class="line">        &lt;CommentList data=&#123;this.state.data&#125; /&gt;</div><div class="line">        &lt;CommentForm /&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在这里，<code>componentDidMount</code>是一种在组件第一次被渲染之后被react调用的方法。动态更新的关键是调用<code>this.state()</code>方法。我们用新的来自服务器的数据替换旧的评论数组，同时UI会自动更新。由于这种反应性，添加实时更新只是一个小的更改。我们将在这里使用简单的<strong><em>polling</em></strong>，但是你可以很容易地使用WebSockets或其他技术。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// tutorial14.js</span></div><div class="line"><span class="keyword">var</span> CommentBox = React.createClass(&#123;</div><div class="line">  loadCommentsFromServer: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    $.ajax(&#123;</div><div class="line">      url: <span class="keyword">this</span>.props.url,</div><div class="line">      dataType: <span class="string">'json'</span>,</div><div class="line">      cache: <span class="literal">false</span>,</div><div class="line">      success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.setState(&#123;data: data&#125;);</div><div class="line">      &#125;.bind(<span class="keyword">this</span>),</div><div class="line">      error: <span class="function"><span class="keyword">function</span>(<span class="params">xhr, status, err</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.error(<span class="keyword">this</span>.props.url, status, err.toString());</div><div class="line">      &#125;.bind(<span class="keyword">this</span>)</div><div class="line">    &#125;);</div><div class="line">  &#125;,</div><div class="line">  getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;data: []&#125;;</div><div class="line">  &#125;,</div><div class="line">  componentDidMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.loadCommentsFromServer();</div><div class="line">    setInterval(<span class="keyword">this</span>.loadCommentsFromServer, <span class="keyword">this</span>.props.pollInterval);</div><div class="line">  &#125;,</div><div class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div className="commentBox"&gt;</div><div class="line">        &lt;h1&gt;Comments&lt;/h1&gt;</div><div class="line">        &lt;CommentList data=&#123;this.state.data&#125; /&gt;</div><div class="line">        &lt;CommentForm /&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">ReactDOM.render(</div><div class="line">  &lt;CommentBox url="/api/comments" pollInterval=&#123;2000&#125; /&gt;,</div><div class="line">  document.getElementById('content')</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>现在我们需要做的是把ajax调用分离成单独的方法，当组件第一次加载时及其后每两秒调用它。试着在你的浏览器中运行它并尝试更改<code>comments.json</code>文件（和服务器在同一文件夹）；不用两秒，更改就会呈现。</p>
<h2 id="添加新评论"><a href="#添加新评论" class="headerlink" title="添加新评论"></a>添加新评论</h2><p>现在是时候建立表单了。我们的<code>CommentForm</code>组件应该询问使用者的姓名和评论文本，然后给服务器发送一个请求来保存评论。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// tutorial15.js</span></div><div class="line"><span class="keyword">var</span> CommentForm = React.createClass(&#123;</div><div class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;form className="commentForm"&gt;</div><div class="line">        &lt;input type="text" placeholder="Your name" /&gt;</div><div class="line">        &lt;input type="text" placeholder="Say something..." /&gt;</div><div class="line">        &lt;input type="submit" value="Post" /&gt;</div><div class="line">      &lt;/form&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h3><p>使用传统的DOM，<code>input</code>元素被渲染并且是浏览器管理这个状态（它的渲染变量）。因此，实际DOM的状态将与组件的状态不同。这个并不理想，因为视图的状态将不同于组件的状态。在React里，组件应该始终表示视图的状态，而不仅仅是初始化时的状态。</p>
<p>因此，我们将使用<code>this.state</code>来保存输入时的用户输入。我们使用两个属性 <code>author</code>和<code>text</code> 来定义初始<code>state</code>，并将它们设置成空字符串。在我们的<code>&lt;input&gt;</code>元素中，我们设置<code>value</code>prop来反应组件状态并绑定了<code>onChange</code>处理程序。这些具有变量的<code>&lt;input&gt;</code>元素被称为受控组件。阅读更多关于受控组件的内容。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// tutorial16.js</span></div><div class="line"><span class="keyword">var</span> CommentForm = React.createClass(&#123;</div><div class="line">  getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;author: <span class="string">''</span>, text: <span class="string">''</span>&#125;;</div><div class="line">  &#125;,</div><div class="line">  handleAuthorChange: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.setState(&#123;author: e.target.value&#125;);</div><div class="line">  &#125;,</div><div class="line">  handleTextChange: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.setState(&#123;text: e.target.value&#125;);</div><div class="line">  &#125;,</div><div class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;form className="commentForm"&gt;</div><div class="line">        &lt;input</div><div class="line">          type="text"</div><div class="line">          placeholder="Your name"</div><div class="line">          value=&#123;this.state.author&#125;</div><div class="line">          onChange=&#123;this.handleAuthorChange&#125;</div><div class="line">        /&gt;</div><div class="line">        &lt;input</div><div class="line">          type="text"</div><div class="line">          placeholder="Say something..."</div><div class="line">          value=&#123;this.state.text&#125;</div><div class="line">          onChange=&#123;this.handleTextChange&#125;</div><div class="line">        /&gt;</div><div class="line">        &lt;input type="submit" value="Post" /&gt;</div><div class="line">      &lt;/form&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>React使用驼峰命名法来绑定时间处理程序。我们给两个<code>&lt;input&gt;</code>元素绑定了<code>onChange</code>处理程序。现在，当用户在<code>&lt;input&gt;</code>中输入文字，绑定的<code>onChange</code>回调函数被激发，并且组件的状态被修改。随后，input元素的已渲染的变量将被更新到现在的组件<code>state</code>。<br>（精明的读者可能会惊讶，这些事件处理程序按描述的那样工作，即时方法引用并没明确的绑定到<code>this</code>。<code>React.createClass(...)</code>会自动将每个方法绑定到其组件实例，避免显式绑定的需要。）</p>
<h3 id="提交表单"><a href="#提交表单" class="headerlink" title="提交表单"></a>提交表单</h3><p>让我们来实现表单交互。当用户提交表单，我们应该清空它，向服务器提交一个请求，并且刷新评论列表。首先，让我们监听表单的提交时间并且清空它。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// tutorial17.js</span></div><div class="line"><span class="keyword">var</span> CommentForm = React.createClass(&#123;</div><div class="line">  getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;author: <span class="string">''</span>, text: <span class="string">''</span>&#125;;</div><div class="line">  &#125;,</div><div class="line">  handleAuthorChange: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.setState(&#123;author: e.target.value&#125;);</div><div class="line">  &#125;,</div><div class="line">  handleTextChange: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.setState(&#123;text: e.target.value&#125;);</div><div class="line">  &#125;,</div><div class="line">  handleSubmit: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    e.preventDefault();</div><div class="line">    <span class="keyword">var</span> author = <span class="keyword">this</span>.state.author.trim();</div><div class="line">    <span class="keyword">var</span> text = <span class="keyword">this</span>.state.text.trim();</div><div class="line">    <span class="keyword">if</span> (!text || !author) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// <span class="doctag">TODO:</span> send request to the server</span></div><div class="line">    <span class="keyword">this</span>.setState(&#123;author: <span class="string">''</span>, text: <span class="string">''</span>&#125;);</div><div class="line">  &#125;,</div><div class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;form className="commentForm" onSubmit=&#123;this.handleSubmit&#125;&gt;</div><div class="line">        &lt;input</div><div class="line">          type="text"</div><div class="line">          placeholder="Your name"</div><div class="line">          value=&#123;this.state.author&#125;</div><div class="line">          onChange=&#123;this.handleAuthorChange&#125;</div><div class="line">        /&gt;</div><div class="line">        &lt;input</div><div class="line">          type="text"</div><div class="line">          placeholder="Say something..."</div><div class="line">          value=&#123;this.state.text&#125;</div><div class="line">          onChange=&#123;this.handleTextChange&#125;</div><div class="line">        /&gt;</div><div class="line">        &lt;input type="submit" value="Post" /&gt;</div><div class="line">      &lt;/form&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>我们给表单绑定了<code>onSubmit</code>处理函数并且在表单提交有效输入后清空表单。</p>
<p>在事件中调用<code>prevenDefault()</code>函数来组织浏览器提交表单的默认操作。</p>
<h3 id="回调函数作为属性"><a href="#回调函数作为属性" class="headerlink" title="回调函数作为属性"></a>回调函数作为属性</h3><p>当一个用户提交了评论，我们需要刷新评论表来增添新评论。在<code>CommentBox</code>中执行这些逻辑更有意义，因为<code>CommentBox</code>拥有能代表评论表单的状态。</p>
<p>我们需要从子组件回传数据到父组件。我们在父组件的<code>render</code>方法中，通过给子组件传递一个新的回调函数（<code>handleCommentSubmit</code>）来实现，绑定它到子节点的<code>onCommentSubmit</code>事件。不管事件什么时候被触发，这个回调函数都会被唤起。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// tutorial18.js</span></div><div class="line"><span class="keyword">var</span> CommentBox = React.createClass(&#123;</div><div class="line">  loadCommentsFromServer: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    $.ajax(&#123;</div><div class="line">      url: <span class="keyword">this</span>.props.url,</div><div class="line">      dataType: <span class="string">'json'</span>,</div><div class="line">      cache: <span class="literal">false</span>,</div><div class="line">      success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.setState(&#123;data: data&#125;);</div><div class="line">      &#125;.bind(<span class="keyword">this</span>),</div><div class="line">      error: <span class="function"><span class="keyword">function</span>(<span class="params">xhr, status, err</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.error(<span class="keyword">this</span>.props.url, status, err.toString());</div><div class="line">      &#125;.bind(<span class="keyword">this</span>)</div><div class="line">    &#125;);</div><div class="line">  &#125;,</div><div class="line">  handleCommentSubmit: <span class="function"><span class="keyword">function</span>(<span class="params">comment</span>) </span>&#123;</div><div class="line">    <span class="comment">// <span class="doctag">TODO:</span> submit to the server and refresh the list</span></div><div class="line">  &#125;,</div><div class="line">  getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;data: []&#125;;</div><div class="line">  &#125;,</div><div class="line">  componentDidMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.loadCommentsFromServer();</div><div class="line">    setInterval(<span class="keyword">this</span>.loadCommentsFromServer, <span class="keyword">this</span>.props.pollInterval);</div><div class="line">  &#125;,</div><div class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div className="commentBox"&gt;</div><div class="line">        &lt;h1&gt;Comments&lt;/h1&gt;</div><div class="line">        &lt;CommentList data=&#123;this.state.data&#125; /&gt;</div><div class="line">        &lt;CommentForm onCommentSubmit=&#123;this.handleCommentSubmit&#125; /&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>既然<code>CommentBox</code>已经通过<code>onCommentSubmit</code>prop给<code>CommentForm</code>提供了回调函数，当用户提交表单的时候<code>CommentForm</code>便要调用回调函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// tutorial19.js</span></div><div class="line"><span class="keyword">var</span> CommentForm = React.createClass(&#123;</div><div class="line">  getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;author: <span class="string">''</span>, text: <span class="string">''</span>&#125;;</div><div class="line">  &#125;,</div><div class="line">  handleAuthorChange: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.setState(&#123;author: e.target.value&#125;);</div><div class="line">  &#125;,</div><div class="line">  handleTextChange: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.setState(&#123;text: e.target.value&#125;);</div><div class="line">  &#125;,</div><div class="line">  handleSubmit: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    e.preventDefault();</div><div class="line">    <span class="keyword">var</span> author = <span class="keyword">this</span>.state.author.trim();</div><div class="line">    <span class="keyword">var</span> text = <span class="keyword">this</span>.state.text.trim();</div><div class="line">    <span class="keyword">if</span> (!text || !author) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.props.onCommentSubmit(&#123;author: author, text: text&#125;);</div><div class="line">    <span class="keyword">this</span>.setState(&#123;author: <span class="string">''</span>, text: <span class="string">''</span>&#125;);</div><div class="line">  &#125;,</div><div class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;form className="commentForm" onSubmit=&#123;this.handleSubmit&#125;&gt;</div><div class="line">        &lt;input</div><div class="line">          type="text"</div><div class="line">          placeholder="Your name"</div><div class="line">          value=&#123;this.state.author&#125;</div><div class="line">          onChange=&#123;this.handleAuthorChange&#125;</div><div class="line">        /&gt;</div><div class="line">        &lt;input</div><div class="line">          type="text"</div><div class="line">          placeholder="Say something..."</div><div class="line">          value=&#123;this.state.text&#125;</div><div class="line">          onChange=&#123;this.handleTextChange&#125;</div><div class="line">        /&gt;</div><div class="line">        &lt;input type="submit" value="Post" /&gt;</div><div class="line">      &lt;/form&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>现在回调已经就绪，我们所要做的就是提交到服务器并刷新列表：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// tutorial20.js</span></div><div class="line"><span class="keyword">var</span> CommentBox = React.createClass(&#123;</div><div class="line">  loadCommentsFromServer: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    $.ajax(&#123;</div><div class="line">      url: <span class="keyword">this</span>.props.url,</div><div class="line">      dataType: <span class="string">'json'</span>,</div><div class="line">      cache: <span class="literal">false</span>,</div><div class="line">      success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.setState(&#123;data: data&#125;);</div><div class="line">      &#125;.bind(<span class="keyword">this</span>),</div><div class="line">      error: <span class="function"><span class="keyword">function</span>(<span class="params">xhr, status, err</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.error(<span class="keyword">this</span>.props.url, status, err.toString());</div><div class="line">      &#125;.bind(<span class="keyword">this</span>)</div><div class="line">    &#125;);</div><div class="line">  &#125;,</div><div class="line">  handleCommentSubmit: <span class="function"><span class="keyword">function</span>(<span class="params">comment</span>) </span>&#123;</div><div class="line">    $.ajax(&#123;</div><div class="line">      url: <span class="keyword">this</span>.props.url,</div><div class="line">      dataType: <span class="string">'json'</span>,</div><div class="line">      type: <span class="string">'POST'</span>,</div><div class="line">      data: comment,</div><div class="line">      success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.setState(&#123;data: data&#125;);</div><div class="line">      &#125;.bind(<span class="keyword">this</span>),</div><div class="line">      error: <span class="function"><span class="keyword">function</span>(<span class="params">xhr, status, err</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.error(<span class="keyword">this</span>.props.url, status, err.toString());</div><div class="line">      &#125;.bind(<span class="keyword">this</span>)</div><div class="line">    &#125;);</div><div class="line">  &#125;,</div><div class="line">  getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;data: []&#125;;</div><div class="line">  &#125;,</div><div class="line">  componentDidMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.loadCommentsFromServer();</div><div class="line">    setInterval(<span class="keyword">this</span>.loadCommentsFromServer, <span class="keyword">this</span>.props.pollInterval);</div><div class="line">  &#125;,</div><div class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div className="commentBox"&gt;</div><div class="line">        &lt;h1&gt;Comments&lt;/h1&gt;</div><div class="line">        &lt;CommentList data=&#123;this.state.data&#125; /&gt;</div><div class="line">        &lt;CommentForm onCommentSubmit=&#123;this.handleCommentSubmit&#125; /&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="优化：优化的更新"><a href="#优化：优化的更新" class="headerlink" title="优化：优化的更新"></a>优化：优化的更新</h2><p>我们的应用现在已经功能齐全，但是它感觉很慢，因为在评论展现在列表前必须要等待服务器请求完成。我们可以优化添加评论到列表来使应用感觉更快。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// tutorial21.js</span></div><div class="line"><span class="keyword">var</span> CommentBox = React.createClass(&#123;</div><div class="line">  loadCommentsFromServer: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    $.ajax(&#123;</div><div class="line">      url: <span class="keyword">this</span>.props.url,</div><div class="line">      dataType: <span class="string">'json'</span>,</div><div class="line">      cache: <span class="literal">false</span>,</div><div class="line">      success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.setState(&#123;data: data&#125;);</div><div class="line">      &#125;.bind(<span class="keyword">this</span>),</div><div class="line">      error: <span class="function"><span class="keyword">function</span>(<span class="params">xhr, status, err</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.error(<span class="keyword">this</span>.props.url, status, err.toString());</div><div class="line">      &#125;.bind(<span class="keyword">this</span>)</div><div class="line">    &#125;);</div><div class="line">  &#125;,</div><div class="line">  handleCommentSubmit: <span class="function"><span class="keyword">function</span>(<span class="params">comment</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> comments = <span class="keyword">this</span>.state.data;</div><div class="line">    <span class="comment">// Optimistically set an id on the new comment. It will be replaced by an</span></div><div class="line">    <span class="comment">// id generated by the server. In a production application you would likely</span></div><div class="line">    <span class="comment">// not use Date.now() for this and would have a more robust system in place.</span></div><div class="line">    comment.id = <span class="built_in">Date</span>.now();</div><div class="line">    <span class="keyword">var</span> newComments = comments.concat([comment]);</div><div class="line">    <span class="keyword">this</span>.setState(&#123;data: newComments&#125;);</div><div class="line">    $.ajax(&#123;</div><div class="line">      url: <span class="keyword">this</span>.props.url,</div><div class="line">      dataType: <span class="string">'json'</span>,</div><div class="line">      type: <span class="string">'POST'</span>,</div><div class="line">      data: comment,</div><div class="line">      success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.setState(&#123;data: data&#125;);</div><div class="line">      &#125;.bind(<span class="keyword">this</span>),</div><div class="line">      error: <span class="function"><span class="keyword">function</span>(<span class="params">xhr, status, err</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.setState(&#123;data: comments&#125;);</div><div class="line">        <span class="built_in">console</span>.error(<span class="keyword">this</span>.props.url, status, err.toString());</div><div class="line">      &#125;.bind(<span class="keyword">this</span>)</div><div class="line">    &#125;);</div><div class="line">  &#125;,</div><div class="line">  getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;data: []&#125;;</div><div class="line">  &#125;,</div><div class="line">  componentDidMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.loadCommentsFromServer();</div><div class="line">    setInterval(<span class="keyword">this</span>.loadCommentsFromServer, <span class="keyword">this</span>.props.pollInterval);</div><div class="line">  &#125;,</div><div class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div className="commentBox"&gt;</div><div class="line">        &lt;h1&gt;Comments&lt;/h1&gt;</div><div class="line">        &lt;CommentList data=&#123;this.state.data&#125; /&gt;</div><div class="line">        &lt;CommentForm onCommentSubmit=&#123;this.handleCommentSubmit&#125; /&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="祝贺你！"><a href="#祝贺你！" class="headerlink" title="祝贺你！"></a>祝贺你！</h2><p>你已经用一些简单的步骤搭建了一个评论框。学习更多关于<a href="">为什么使用React</a>，或者跳转到<a href="">API指南</a>来开始编程！祝你好运。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Webpack配置教程]]></title>
      <url>http://yoursite.com/2017/03/07/Webpack%E6%8E%A2%E7%B4%A2/</url>
      <content type="html"><![CDATA[<p><img src="https://ooo.0o0.ooo/2017/03/08/58bef2f11655f.png" alt="依赖项"><br><a href="https://github.com/ssbabysong/webpack-study" target="_blank" rel="external">代码地址</a><br><a id="more"></a></p>
<h2 id="最终配置文件"><a href="#最终配置文件" class="headerlink" title="最终配置文件"></a>最终配置文件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//webpack.config.js</span></div><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> config = &#123;</div><div class="line">  entry: path.resolve(__dirname, <span class="string">'app/main.js'</span>),</div><div class="line">  output: &#123;</div><div class="line">    path: path.resolve(__dirname, <span class="string">'build'</span>),</div><div class="line">    filename: <span class="string">'bundle.js'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="built_in">module</span>: &#123;</div><div class="line">    loaders: [</div><div class="line">      &#123;</div><div class="line">        test: <span class="regexp">/\.jsx?$/</span>,         <span class="comment">// Match both .js and .jsx files</span></div><div class="line">        exclude: <span class="regexp">/node_modules/</span>, </div><div class="line">        loader: <span class="string">"babel-loader"</span>, </div><div class="line">        query:</div><div class="line">          &#123;</div><div class="line">            presets:[<span class="string">'react'</span>]</div><div class="line">          &#125;</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        test: <span class="regexp">/\.css$/</span>, <span class="comment">// Only .css files</span></div><div class="line">        loader: <span class="string">'style-loader!css-loader?modules'</span> </div><div class="line">      &#125;,</div><div class="line">      <span class="comment">// SASS</span></div><div class="line">      &#123;</div><div class="line">        test: <span class="regexp">/\.scss$/</span>,</div><div class="line">        loader: <span class="string">'style-loader!css-loader!sass-loader?modules'</span></div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        test: <span class="regexp">/\.(png|jpg)$/</span>,</div><div class="line">        loader: <span class="string">'url?limit=25000'</span></div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        test: <span class="regexp">/\.woff$/</span>,</div><div class="line">        loader: <span class="string">'url?limit=100000'</span></div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  plugins: [</div><div class="line">    <span class="keyword">new</span> webpack.BannerPlugin(<span class="string">'This file is created by chenss'</span>)</div><div class="line">  ]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = config;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//package.json</span></div><div class="line"><span class="string">"scripts"</span>: &#123;</div><div class="line">    <span class="string">"build"</span>: <span class="string">"webpack"</span>,</div><div class="line">    <span class="string">"dev"</span>: <span class="string">"webpack-dev-server --devtool eval --progress --colors --hot --content-base build"</span></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><ol>
<li><p>新建项目文件结构</p>
<pre><code>|app
|——|main.js
|——|components
|————|components.jsx
|————|components.scss
|build
|——|bundle.js (自动创建)
|——|index.html
|package.json
|webpack.config.js
</code></pre></li>
<li><code>npm init</code>进行初始化</li>
<li><code>npm install -g webpack</code>全局安装webpack</li>
<li><code>npm install --save-dev webpack</code>安装到你的项目目录</li>
<li><code>npm i webpack-dev-server --save-dev</code>装webpack server</li>
<li><code>npm run dev</code>本地服务器运行</li>
<li><p>配置react环境</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">npm install babel-loader --save-dev</div><div class="line">npm install react react-dom --save-dev </div><div class="line">npm install babel-preset-react</div></pre></td></tr></table></figure>
</li>
<li><p><code>npm install css-loader style-loader --save-dev</code>装css加载</p>
</li>
<li><code>npm install sass-loader --save-dev</code>装sass加载(先装node-sass)</li>
<li><code>npm install url-loader --save-dev</code>装图片url加载</li>
<li>css模块化</li>
<li>引入BannerPlugin插件</li>
</ol>
<blockquote>
<p><strong>番外：</strong><br>有时候可能希望项目的样式能不要被打包到脚本中，而是独立出来作为.css，然后在页面中以<link>标签引入。这时候我们需要 extract-text-webpack-plugin 来帮忙：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</div><div class="line">    <span class="keyword">var</span> commonsPlugin = <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(<span class="string">'common.js'</span>);</div><div class="line">    <span class="keyword">var</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">"extract-text-webpack-plugin"</span>);</div><div class="line"> </div><div class="line">    <span class="built_in">module</span>.exports = &#123;</div><div class="line">        plugins: [commonsPlugin, <span class="keyword">new</span> ExtractTextPlugin(<span class="string">"[name].css"</span>)],</div><div class="line">        entry: &#123;</div><div class="line">        <span class="comment">//...省略其它配置</span></div></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[React中文文档(一)Getting Started]]></title>
      <url>http://yoursite.com/2017/03/06/React%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3(%E4%B8%80)/</url>
      <content type="html"><![CDATA[<p><img src="https://ooo.0o0.ooo/2017/03/08/58bf86c6ce2b1.jpg" alt="react"></p>
<p>本文翻译自<a href="http://reactjs.cn/react/docs/getting-started.html" target="_blank" rel="external">React官网教程</a>,欢迎指出错误。<br><a id="more"></a></p>
<h2 id="JSFiddle"><a href="#JSFiddle" class="headerlink" title="JSFiddle"></a>JSFiddle</h2><p>开始学习 React 的最简单的方法是用下面 JSFiddle 的 Hello World例子：</p>
<ul>
<li><a href="https://jsfiddle.net/reactjs/69z2wepo/" target="_blank" rel="external">React JSFiddle</a></li>
<li><a href="https://jsfiddle.net/reactjs/5vjqabv3/" target="_blank" rel="external">React JSFiddle without JSX</a></li>
</ul>
<h2 id="初始包"><a href="#初始包" class="headerlink" title="初始包"></a>初始包</h2><p>如果你只是刚入门，你可以下载初始套件。它包含了预编译好的React和React DOM，还有一些用例代码来帮你更快入门。</p>
<p><div style="text-align:center"><a href="http://reactjs.cn/react/downloads/react-15.3.1.zip" style="font-size:15px;color:#286834;border:1px solid green;border-radius:5px;display:inline-block;padding:5px;width:250px;line-height:30px" target="_blank" rel="external">下载初始套件</a></div><br></p>
<p>在套件的根目录下新建<code>helloworld.html</code>，代码如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello React!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"build/react.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"build/react-dom.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://npmcdn.com/babel-core@5.8.38/browser.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span><span class="xml"></span></div><div class="line">      ReactDOM.render(</div><div class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>,</div><div class="line">        document.getElementById('example')</div><div class="line">      );</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>JavaScript中包含的类似XML的语法叫做JSX。你可以通过学习后面的JSX语法教程来学习。我们使用<code>&lt;script type=&quot;text/babel&quot;&gt;</code>把它转换成普通Javascript代码，引入babel实现在浏览器中的代码转换。现在在浏览器中打开这个html文件就可以看到欢迎界面！</p>
<h3 id="分离文件"><a href="#分离文件" class="headerlink" title="分离文件"></a>分离文件</h3><p>你的React代码可以被单独放置在一个文件里。新建<code>src/helloworld.js</code>文件。<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ReactDOM.render(</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>,</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>然后在<code>helloworld.html</code>中链接它<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span> <span class="attr">src</span>=<span class="string">"src/helloworld.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>注意，一些浏览器（比如Chrome）中加载不出文件，除非它已经运行在服务器中。</p>
<h2 id="使用React"><a href="#使用React" class="headerlink" title="使用React"></a>使用React</h2><p>你可以通过以下三种方法使用React</p>
<h3 id="使用托管在CDN上的React"><a href="#使用托管在CDN上的React" class="headerlink" title="使用托管在CDN上的React"></a>使用托管在CDN上的React</h3><p>我们在<a href="http://reactjs.cn/react/downloads.html" target="_blank" rel="external">下载页面</a>提供了托管在CDN上的版本。这些预编译的文件使用UMD格式化。通过<code>&lt;script&gt;</code>标签来把<code>React</code>和<code>ReactDOM</code>引入你的全局环境。<strong><em>It should also work out-of-the-box in CommonJS and AMD environments.</em></strong></p>
<h3 id="通过npm使用React"><a href="#通过npm使用React" class="headerlink" title="通过npm使用React"></a>通过npm使用React</h3><p>你可以在React中使用CommonJS模块系统，比如<a href="http://browserify.org/" target="_blank" rel="external">browserify</a>和<a href="https://webpack.github.io/" target="_blank" rel="external">webpack</a>。来使用<a href="https://www.npmjs.com/package/react" target="_blank" rel="external">react</a>和<a href="https://www.npmjs.com/package/react-dom" target="_blank" rel="external">react-dom</a> npm包。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">'react'</span>);</div><div class="line"><span class="keyword">var</span> ReactDOM = <span class="built_in">require</span>(<span class="string">'react-dom'</span>);</div><div class="line"></div><div class="line">ReactDOM.render(</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>,</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>使用<code>.babelrc</code>文件来配置<code>babel</code><br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="attr">"presets"</span>: [<span class="string">"react"</span>] &#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>Note:</strong><br>如果你在使用ES2015，你也需要使用<code>babel-preset-es2015</code>包</p>
</blockquote>
<ul>
<li><p>使用browserify安装React DOM和构建你的包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ npm install --save react react-dom babelify babel-preset-react</div><div class="line">$ browserify -t [ babelify ] main.js -o bundle.js</div></pre></td></tr></table></figure>
</li>
<li><p>使用webpack安装React DOM和构建你的包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ npm install --save react react-dom babel-preset-react babel-loader babel-core</div><div class="line">$ webpack main.js bundle.js --module-bind &apos;js=babel-loader&apos;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>Note:</strong><br>React默认的是开发模式，速度缓慢不建议呗用于生产中。为了使用生产模式，要把环境变量<code>NODE_ENV</code>改为<code>produxtion</code>（<strong><em>using envify or webpack’s DefinePlugin</em></strong>）。比如，<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> webpack.DefinePlugin(&#123;</div><div class="line">  <span class="string">"process.env"</span>: &#123;</div><div class="line">    NODE_ENV: <span class="built_in">JSON</span>.stringify(<span class="string">"production"</span>)</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>html文件更新为<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello React!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"build/react.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"build/react-dom.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- No need for Babel! --&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"build/helloworld.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="通过Bower使用React"><a href="#通过Bower使用React" class="headerlink" title="通过Bower使用React"></a>通过Bower使用React</h3><p>Bower是一个用于前端优化开发的包管理器。如果多个包依赖于一个包，比如jquery，Bower将只需下载一次jquery。<strong><em>This is known as a flat dependency graph and it helps reduce page load. </em></strong>想了解更多的信息，去访问它的<a href="http://bower.io/" target="_blank" rel="external">官网</a>。</p>
<p>如果你使用bower，同样很容易<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bower install --save react</div></pre></td></tr></table></figure></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello React!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bower_components/react/react.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bower_components/react/react-dom.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://npmcdn.com/babel-core@5.8.38/browser.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span><span class="javascript"></span></div><div class="line">      ReactDOM.render(</div><div class="line">        <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>,</div><div class="line">        <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</div><div class="line">      );</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Javascript学习笔记]]></title>
      <url>http://yoursite.com/2016/09/02/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p><img src="https://udemy-images.udemy.com/course/750x422/672274_cd11_2.jpg" alt="javascript学习笔记"><br>[数组+函数+对象+面向对象]<a id="more"></a></p>
<h3 id="Firstly"><a href="#Firstly" class="headerlink" title="Firstly"></a>Firstly</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><h5 id="几种常用方法："><a href="#几种常用方法：" class="headerlink" title="几种常用方法："></a>几种常用方法：</h5><ul>
<li><code>indexOf()</code> 来搜索一个指定的元素的位置</li>
<li><p><code>slice()</code>就是对应String的<code>substring()</code>版本，它截取Array的部分元素，然后返回一个新的Array。</p>
<ul>
<li><p>注意到<code>slice()</code>的起止参数包括开始索引，不包括结束索引。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>];</div><div class="line">arr.slice(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']</span></div><div class="line">arr.slice(<span class="number">3</span>); <span class="comment">// 从索引3开始到结束: ['D', 'E', 'F', 'G']</span></div></pre></td></tr></table></figure>
</li>
<li><p>如果不给<code>slice()</code>传递任何参数，它就会从头到尾截取所有元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>];</div><div class="line"><span class="keyword">var</span> aCopy = arr.slice();</div><div class="line">aCopy; <span class="comment">// ['A', 'B', 'C', 'D', 'E', 'F', 'G']</span></div><div class="line">aCopy === arr; <span class="comment">// false</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><code>push()</code>向Array的末尾添加若干元素，<code>pop()</code>则把Array的最后一个元素删除掉：</li>
<li>如果要往Array的头部添加若干元素，使用<code>unshift()</code>方法，<code>shift()</code>方法则把Array的第一个元素删掉</li>
<li><p><code>splice()</code>方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arr.splice(<span class="number">2</span>, <span class="number">3</span>, <span class="string">'Google'</span>, <span class="string">'Facebook'</span>);<span class="comment">//从索引2开始删除三个元素并添加两个元素</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>join()</code>方法把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串</p>
</li>
</ul>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><ul>
<li>如果我们要检测xiaoming是否拥有某一属性，可以用<code>in</code>操作符：<code>&#39;name&#39; in xiaoming</code>;</li>
<li>不过要小心，如果in判断一个属性存在，这个属性不一定是xiaoming的，它可能是xiaoming继承得到的：要判断一个属性是否是xiaoming自身拥有的，而不是继承得到的，可以用<code>hasOwnProperty(&#39;name&#39;)</code>方法：</li>
</ul>
<h4 id="Map和Set"><a href="#Map和Set" class="headerlink" title="Map和Set"></a>Map和Set</h4><p>JavaScript的默认对象表示方式{}可以视为其他语言中的Map或Dictionary的数据结构，即一组键值对。但是JavaScript的对象有个小问题，就是键必须是字符串。但实际上Number或者其他数据类型作为键也是非常合理的。</p>
<ul>
<li><p>为了解决这个问题，最新的ES6规范引入了新的数据类型Map</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'Michael'</span>, <span class="number">95</span>], [<span class="string">'Bob'</span>, <span class="number">75</span>], [<span class="string">'Tracy'</span>, <span class="number">85</span>]]);</div><div class="line">m.get(<span class="string">'Michael'</span>); <span class="comment">// 95</span></div><div class="line">m.set(<span class="string">'Adam'</span>, <span class="number">67</span>); <span class="comment">// 添加新的key-value</span></div></pre></td></tr></table></figure>
</li>
<li><p>Set和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">// 空Set</span></div><div class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// 含1, 2, 3</span></div><div class="line"><span class="comment">//重复元素在Set中自动被过滤</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="iterable"><a href="#iterable" class="headerlink" title="iterable"></a>iterable</h4><p>遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。具有iterable类型的集合可以通过新的<code>for ... of</code>循环来遍历。(<code>for ... of</code>循环是ES6引入的新的语法)</p>
<h5 id="for-…-of循环和for-…-in循环有何区别？"><a href="#for-…-of循环和for-…-in循环有何区别？" class="headerlink" title="for … of循环和for … in循环有何区别？"></a>for … of循环和for … in循环有何区别？</h5><p>for … of循环只循环集合本身的元素 in还遍历继承来的属性</p>
<h5 id="forEach方法"><a href="#forEach方法" class="headerlink" title="forEach方法"></a>forEach方法</h5><p>更好的方法是<code>forEach</code>方法，它接收一个函数，每次迭代就自动回调该函数。以Array为例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</div><div class="line">a.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element, index, array</span>) </span>&#123;</div><div class="line">	<span class="comment">// element: 指向当前元素的值</span></div><div class="line">	<span class="comment">// index: 指向当前索引</span></div><div class="line">	<span class="comment">// array: 指向Array对象本身</span></div><div class="line">	alert(element);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>Set与Array类似，但Set没有索引，因此回调函数的前两个参数都是元素本身：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]);</div><div class="line">s.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element, sameElement, set</span>) </span>&#123;</div><div class="line">	alert(element);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>Map的回调函数参数依次为value、key和map本身：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">'x'</span>], [<span class="number">2</span>, <span class="string">'y'</span>], [<span class="number">3</span>, <span class="string">'z'</span>]]);</div><div class="line">m.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value, key, map</span>) </span>&#123;</div><div class="line">	alert(value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h4><p>JavaScript还有一个免费赠送的关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">	alert(x); <span class="comment">// 10</span></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="built_in">arguments</span>.length; i++) &#123;</div><div class="line">   	 alert(<span class="built_in">arguments</span>[i]); <span class="comment">// 10, 20, 30</span></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">foo(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</div></pre></td></tr></table></figure></p>
<p>arguments最常用于判断传入参数的个数。你可能会看到这样的写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// foo(a[, b], c)</span></div><div class="line"><span class="comment">// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, c</span>) </span>&#123;</div><div class="line">	<span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</div><div class="line">    	<span class="comment">// 实际拿到的参数是a和b，c为undefined</span></div><div class="line">   	 	c = b; <span class="comment">// 把b赋给c</span></div><div class="line">    	b = <span class="literal">null</span>; <span class="comment">// b变为默认值</span></div><div class="line">	&#125;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="rest"><a href="#rest" class="headerlink" title="rest"></a>rest</h4><p>要把中间的参数b变为“可选”参数，就只能通过arguments判断，然后重新调整参数并赋值。<br>ES6标准引入了rest参数，上面的函数可以改写为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, ...rest</span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'a = '</span> + a);</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'b = '</span> + b);</div><div class="line">	<span class="built_in">console</span>.log(rest);</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</div><div class="line"><span class="comment">// 结果:</span></div><div class="line"><span class="comment">// a = 1</span></div><div class="line"><span class="comment">// b = 2</span></div><div class="line"><span class="comment">// Array [ 3, 4, 5 ]</span></div><div class="line"></div><div class="line">foo(<span class="number">1</span>);</div><div class="line"><span class="comment">// 结果:</span></div><div class="line"><span class="comment">// a = 1</span></div><div class="line"><span class="comment">// b = undefined</span></div><div class="line"><span class="comment">// Array []</span></div></pre></td></tr></table></figure></p>
<ul>
<li><p>rest参数只能写在最后，前面用…标识，从运行结果可知，传入的参数先绑定a、b，多余的参数以数组形式交给变量rest，所以，不再需要arguments我们就获取了全部参数。</p>
</li>
<li><p>如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个空数组（注意不是undefined）。</p>
</li>
</ul>
<h4 id="名字空间"><a href="#名字空间" class="headerlink" title="名字空间"></a>名字空间</h4><p>全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。</p>
<p>减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 唯一的全局变量MYAPP:</span></div><div class="line"><span class="keyword">var</span> MYAPP = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 其他变量:</span></div><div class="line">MYAPP.name = <span class="string">'myapp'</span>;</div><div class="line">MYAPP.version = <span class="number">1.0</span>;</div><div class="line"></div><div class="line"><span class="comment">// 其他函数:</span></div><div class="line">MYAPP.foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="string">'foo'</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="apply-call"><a href="#apply-call" class="headerlink" title="apply call"></a>apply call</h4><p>要指定函数的this指向哪个对象，可以用函数本身的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。</p>
<p>用apply修复<code>getAge()</code>调用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</div><div class="line">	<span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="keyword">var</span> xiaoming = &#123;</div><div class="line">	name: <span class="string">'小明'</span>,</div><div class="line">	birth: <span class="number">1990</span>,</div><div class="line">	age: getAge</div><div class="line">&#125;;</div><div class="line">	</div><div class="line">xiaoming.age(); <span class="comment">// 25</span></div><div class="line">getAge.apply(xiaoming, []); <span class="comment">// 25, this指向xiaoming, 参数为空</span></div></pre></td></tr></table></figure></p>
<p>另一个与<code>apply()</code>类似的方法是<code>call()</code>，唯一区别是：</p>
<p><code>apply()</code>把参数打包成Array再传入；</p>
<p><code>call()</code>把参数按顺序传入。</p>
<p>比如调用<code>Math.max(3, 5, 4)</code>，分别用apply()和call()实现如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>]); <span class="comment">// 5</span></div><div class="line"><span class="built_in">Math</span>.max.call(<span class="literal">null</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>); <span class="comment">// 5</span></div></pre></td></tr></table></figure></p>
<p>对普通函数调用，我们通常把this绑定为null。</p>
<h4 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h4><p>利用apply()，我们还可以动态改变函数的行为。</p>
<p>JavaScript的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。</p>
<p>现在假定我们想统计一下代码一共调用了多少次<code>parseInt()</code>，可以把所有的调用都找出来，然后手动加上<code>count += 1</code>，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的parseInt()：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</div><div class="line"><span class="keyword">var</span> oldParseInt = <span class="built_in">parseInt</span>; <span class="comment">// 保存原函数</span></div><div class="line"></div><div class="line"><span class="built_in">window</span>.parseInt = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	count += <span class="number">1</span>;</div><div class="line">	<span class="keyword">return</span> oldParseInt.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>); <span class="comment">// 调用原函数</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 测试:</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>);</div><div class="line"><span class="built_in">parseInt</span>(<span class="string">'20'</span>);</div><div class="line"><span class="built_in">parseInt</span>(<span class="string">'30'</span>);</div><div class="line">count; <span class="comment">// 3</span></div></pre></td></tr></table></figure></p>
<h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><p>把函数作为参数传到另一个函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y, f</span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> f(x) + f(y);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><p>map方法定义在Array中，参数是函数，对数组每一项执行函数。</p>
<p>所以，<code>map()</code>作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的<code>f(x)=x2</code>，还可以计算任意复杂的函数，比如，把Array的所有数字转为字符串：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</div><div class="line">arr.map(<span class="built_in">String</span>); <span class="comment">// ['1', '2', '3', '4', '5', '6', '7', '8', '9']</span></div></pre></td></tr></table></figure></p>
<p>只需要一行代码。</p>
<h5 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h5><p>比方说对一个Array求和，就可以用reduce实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>];</div><div class="line">arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> x + y;</div><div class="line">&#125;); <span class="comment">// 25</span></div></pre></td></tr></table></figure></p>
<p>要把[1, 3, 5, 7, 9]变换成整数13579，<code>reduce()</code>也能派上用场：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>];</div><div class="line">arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> x * <span class="number">10</span> + y;</div><div class="line">&#125;); <span class="comment">// 13579</span></div><div class="line"><span class="string">``</span><span class="string">`	</span></div><div class="line">如果我们继续改进这个例子，想办法把一个字符串13579先变成Array——[1, 3, 5, 7, 9]，再利用`reduce()<span class="string">`就可以写出一个把字符串转换为Number的函数。</span></div><div class="line"></div><div class="line">练习：不要使用JavaScript内置的`<span class="built_in">parseInt</span>()<span class="string">`函数，利用map和reduce操作实现一个`</span>string2int()<span class="string">`函数：</span></div><div class="line">`<span class="string">``</span>javascript</div><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">string2int</span>(<span class="params">s</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> arr = s.split();</div><div class="line"></div><div class="line">	<span class="keyword">return</span> arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> +x;&#125;).reduce(<span class="function"><span class="keyword">function</span> (<span class="params">x,y</span>)</span>&#123;<span class="keyword">return</span> x*<span class="number">10</span>+y;&#125;)</div><div class="line">&#125;</div><div class="line"><span class="string">``</span><span class="string">`	</span></div><div class="line">练习</div><div class="line"></div><div class="line">请把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：['adam', 'LISA', 'barT']，输出：['Adam', 'Lisa', 'Bart']。</div><div class="line">`<span class="string">``</span>javascript</div><div class="line"><span class="meta">'use strict'</span>;</div><div class="line">	</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalize</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>)</span>&#123;<span class="keyword">var</span> tail = x.substring(<span class="number">1</span>).toLowerCase();<span class="keyword">var</span> head = x[<span class="number">0</span>].toUpperCase();<span class="keyword">return</span> head + tail;&#125;)</div><div class="line">｝</div></pre></td></tr></table></figure></p>
<p>练习</p>
<p>利用map()把字符串变成整数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>];</div><div class="line"><span class="keyword">var</span> r;</div><div class="line"></div><div class="line">r = arr.map(r = arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> +x;&#125;););</div><div class="line"></div><div class="line">alert(<span class="string">'['</span> + r[<span class="number">0</span>] + <span class="string">', '</span> + r[<span class="number">1</span>] + <span class="string">', '</span> + r[<span class="number">2</span>] + <span class="string">']'</span>);</div></pre></td></tr></table></figure></p>
<h5 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h5><p>参数也是函数，把函数作用于每个元素，根据return true还是false来决定保留还是丢弃元素</p>
<h5 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h5><p>sort按照ascii码进行排序，但<code>sort()</code>方法也是一个高阶函数，也可以接收一个比较函数来实现自定义的排序。！</p>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>在面向对象的程序设计语言里，比如Java和C++，要在对象内部封装一个私有变量，可以用private修饰一个成员变量。</p>
<p>在没有class机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。我们用JavaScript创建一个计数器：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">create_counter</span>(<span class="params">initial</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> x = initial || <span class="number">0</span>;</div><div class="line">	<span class="keyword">return</span> &#123;</div><div class="line">    	inc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        	x += <span class="number">1</span>;</div><div class="line">        	<span class="keyword">return</span> x;</div><div class="line">    	&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它用起来像这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> c1 = create_counter();</div><div class="line">c1.inc(); <span class="comment">// 1</span></div><div class="line">c1.inc(); <span class="comment">// 2</span></div><div class="line">c1.inc(); <span class="comment">// 3</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> c2 = create_counter(<span class="number">10</span>);</div><div class="line">c2.inc(); <span class="comment">// 11</span></div><div class="line">c2.inc(); <span class="comment">// 12</span></div><div class="line">c2.inc(); <span class="comment">// 13</span></div></pre></td></tr></table></figure></p>
<p>在返回的对象中，实现了一个闭包，该闭包携带了局部变量x，并且，从外部代码根本无法访问到变量x。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。</p>
<p>闭包还可以把多参数的函数变成单参数的函数。例如，要计算xy可以用<code>Math.pow(x, y)</code>函数，不过考虑到经常计算x2或x3，我们可以利用闭包创建新的函数pow2和pow3：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">make_pow</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">    	<span class="keyword">return</span> <span class="built_in">Math</span>.pow(x, n);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 创建两个新函数:</span></div><div class="line"><span class="keyword">var</span> pow2 = make_pow(<span class="number">2</span>);</div><div class="line"><span class="keyword">var</span> pow3 = make_pow(<span class="number">3</span>);</div><div class="line"></div><div class="line">pow2(<span class="number">5</span>); <span class="comment">// 25</span></div><div class="line">pow3(<span class="number">7</span>); <span class="comment">// 343</span></div></pre></td></tr></table></figure></p>
<p>定义运算<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"></div><div class="line"><span class="comment">// 定义数字0:</span></div><div class="line"><span class="keyword">var</span> zero = <span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">    	<span class="keyword">return</span> x;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 定义数字1:</span></div><div class="line"><span class="keyword">var</span> one = <span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">    	<span class="keyword">return</span> f(x);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 定义加法:</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n, m</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123;</div><div class="line">    	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">        	<span class="keyword">return</span> m(f)(n(f)(x));</div><div class="line">    	&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><em>参见维基百科<a href="https://zh.wikipedia.org/wiki/%CE%9B%E6%BC%94%E7%AE%97" target="_blank" rel="external">λ演算</a></em></p>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p><em>ES6新增函数 Arrow Function</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x =&gt; x * x</div></pre></td></tr></table></figure></p>
<p>上面的箭头函数相当于一个匿名函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> x * x;</div><div class="line">&#125;</div><div class="line"><span class="string">``</span><span class="string">`	</span></div><div class="line">- =&gt;前代表参数：如果有多个参数，用括号括起来(x,y)=&gt;</div><div class="line">- 如果要返回一个对象，x =&gt; (&#123; foo: x &#125;)，要和函数体本身的｛...｝区分开</div><div class="line"></div><div class="line">*箭头函数与匿名函数的区别：箭头函数内部的this是词法作用域，也就是外层调用者obj，由上下文确定*</div><div class="line"></div><div class="line">*由于this在箭头函数中已经按照词法作用域绑定了，所以，用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略*</div><div class="line"></div><div class="line">#### generator</div><div class="line">generator（生成器）是ES6标准引入的新的数据类型。一个generator看上去像一个函数，但可以返回多次。</div><div class="line"></div><div class="line">直接调用一个generator和调用函数不一样，fib(5)仅仅是创建了一个generator对象，还没有去执行它。</div><div class="line"></div><div class="line">调用generator对象有两个方法，一是不断地调用generator对象的`next()<span class="string">`方法：</span></div><div class="line">`<span class="string">``</span>javascript</div><div class="line"><span class="keyword">var</span> f = fib(<span class="number">5</span>);</div><div class="line">f.next(); <span class="comment">// &#123;value: 0, done: false&#125;</span></div><div class="line">f.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></div><div class="line">f.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></div><div class="line">f.next(); <span class="comment">// &#123;value: 2, done: false&#125;</span></div><div class="line">f.next(); <span class="comment">// &#123;value: 3, done: true&#125;</span></div></pre></td></tr></table></figure></p>
<p>next()方法会执行generator的代码，然后，每次遇到yield x;就返回一个对象{value: x, done: true/false}，然后“暂停”。返回的value就是yield的返回值，done表示这个generator是否已经执行结束了。如果done为true，则value就是return的返回值。</p>
<p>当执行到done为true时，这个generator对象就已经全部执行完毕，不要再继续调用next()了。</p>
<p>第二个方法是直接用<code>for ... of</code>循环迭代generator对象，这种方式不需要我们自己判断done：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> fib(<span class="number">5</span>)) &#123;</div><div class="line">	<span class="built_in">console</span>.log(x); <span class="comment">// 依次输出0, 1, 1, 2, 3</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="标准对象"><a href="#标准对象" class="headerlink" title="标准对象"></a>标准对象</h3><ul>
<li><p>不要使用<code>new Number()</code>、<code>new Boolean()</code>、<code>new String()</code>创建包装对象；</p>
</li>
<li><p>用<code>parseInt()</code>或<code>parseFloat()</code>来转换任意类型到number；</p>
</li>
<li><p>用<code>String()</code>来转换任意类型到string，或者直接调用某个对象的<code>toString()</code>方法；</p>
</li>
<li><p>通常不必把任意类型转换为boolean再判断，因为可以直接写<code>if (myVar) {...}</code>；</p>
</li>
<li><p>typeof操作符可以判断出number、boolean、string、function和undefined；</p>
</li>
<li><p>判断Array要使用<code>Array.isArray(arr)</code>；</p>
</li>
<li><p>判断null请使用<code>myVar === null</code>；</p>
</li>
<li><p>判断某个全局变量是否存在用<code>typeof window.myVar === &#39;undefined&#39;</code>；</p>
</li>
<li><p>函数内部判断某个变量是否存在用<code>typeof myVar === &#39;undefined&#39;</code>。</p>
</li>
<li>number对象调用<code>toString()</code>报SyntaxError：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">123.</span>toString(); <span class="comment">// SyntaxError</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>遇到这种情况，要特殊处理一下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">123.</span>.toString(); <span class="comment">// '123', 注意是两个点！</span></div><div class="line">(<span class="number">123</span>).toString(); <span class="comment">// '123'</span></div></pre></td></tr></table></figure></p>
<h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">now; <span class="comment">// Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span></div><div class="line">now.getFullYear(); <span class="comment">// 2015, 年份</span></div><div class="line">now.getMonth(); <span class="comment">// 5, 月份，注意月份范围是0~11，5表示六月</span></div><div class="line">now.getDate(); <span class="comment">// 24, 表示24号</span></div><div class="line">now.getDay(); <span class="comment">// 3, 表示星期三</span></div><div class="line">now.getHours(); <span class="comment">// 19, 24小时制</span></div><div class="line">now.getMinutes(); <span class="comment">// 49, 分钟</span></div><div class="line">now.getSeconds(); <span class="comment">// 22, 秒</span></div><div class="line">now.getMilliseconds(); <span class="comment">// 875, 毫秒数</span></div><div class="line">now.getTime(); <span class="comment">// 1435146562875, 以number形式表示的时间戳</span></div><div class="line"><span class="string">``</span><span class="string">`	</span></div><div class="line">*ps:getmouth()从0-11*</div><div class="line">#### RegExp</div><div class="line">用*表示任意个字符（包括0个），用+表示至少一个字符，用?表示0个或1个字符，用&#123;n&#125;表示n个字符，用&#123;n,m&#125;表示n-m个字符</div><div class="line"></div><div class="line">##### 创建正则表达式：</div><div class="line"></div><div class="line">1. /.../</div><div class="line">2. new RegExp('...')</div><div class="line"></div><div class="line">两种写法是一样的：</div><div class="line">`<span class="string">``</span>javascript</div><div class="line"><span class="keyword">var</span> re1 = <span class="regexp">/ABC\-001/</span>;</div><div class="line"><span class="keyword">var</span> re2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'ABC\\-001'</span>);</div><div class="line"></div><div class="line">re1; <span class="comment">// /ABC\-001/</span></div><div class="line">re2; <span class="comment">// /ABC\-001/</span></div></pre></td></tr></table></figure>
<p>注意，如果使用第二种写法，因为字符串的转义问题，字符串的两个\实际上是一个\。</p>
<p>先看看如何判断正则表达式是否匹配：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> re = <span class="regexp">/^\d&#123;3&#125;\-\d&#123;3,8&#125;$/</span>;</div><div class="line">re.test(<span class="string">'010-12345'</span>); <span class="comment">// true</span></div><div class="line">re.test(<span class="string">'010-1234x'</span>); <span class="comment">// false</span></div><div class="line">re.test(<span class="string">'010 12345'</span>); <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>RegExp对象的<code>test()</code>方法用于测试给定的字符串是否符合条件。</p>
<h5 id="提取子串：exec"><a href="#提取子串：exec" class="headerlink" title="提取子串：exec();"></a>提取子串：<code>exec()</code>;</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$/</span>;</div><div class="line">re.exec(<span class="string">'010-12345'</span>); <span class="comment">// ['010-12345', '010', '12345']</span></div><div class="line">re.exec(<span class="string">'010 12345'</span>); <span class="comment">// null</span></div><div class="line"><span class="string">``</span><span class="string">`	</span></div><div class="line">- exec()方法在匹配成功后，会返回一个Array，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。</div><div class="line">- exec()方法在匹配失败时返回null。</div><div class="line">##### 贪婪匹配</div><div class="line">正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0：</div><div class="line">`<span class="string">``</span>javascript</div><div class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d+)(0*)$/</span>;</div><div class="line">re.exec(<span class="string">'102300'</span>); <span class="comment">// ['102300', '102300', '']</span></div></pre></td></tr></table></figure>
<p>由于\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。</p>
<p>必须让\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\d+采用非贪婪匹配：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d+?)(0*)$/</span>;</div><div class="line">re.exec(<span class="string">'102300'</span>); <span class="comment">// ['102300', '1023', '00']</span></div></pre></td></tr></table></figure></p>
<h5 id="全局搜索"><a href="#全局搜索" class="headerlink" title="全局搜索"></a>全局搜索</h5><p>g：全局搜索<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> r1 = <span class="regexp">/test/g</span>;</div><div class="line"><span class="comment">// 等价于:</span></div><div class="line"><span class="keyword">var</span> r2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'test'</span>, <span class="string">'g'</span>);</div></pre></td></tr></table></figure></p>
<p>全局匹配可以多次执行<code>exec()</code>方法来搜索一个匹配的字符串。当我们指定g标志后，每次运行<code>exec()</code>，正则表达式本身会更新lastIndex属性，表示上次匹配到的最后索引</p>
<p>i：忽略大小写</p>
<p>m：执行多行匹配<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> re =  <span class="regexp">/^\w+\.?\w+@\w+\.(com|org)/</span>;</div><div class="line"><span class="comment">//正则的｛｝里表示匹配次数</span></div><div class="line"><span class="comment">//()表示的就是要提取的分组（Group）</span></div><div class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$/</span>;</div></pre></td></tr></table></figure></p>
<h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p>JavaScript Object Notation</p>
<p>JSON是一种数据交换格式，很多高级语言内置了JSON库。<br>1.序列化（把JavaScript对象变成JSON）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//首先定义一个对象xiaoming</span></div><div class="line"><span class="keyword">var</span> xiaoming&#123;</div><div class="line">	name:<span class="string">'小明'</span>，</div><div class="line">	age:<span class="number">13</span>,</div><div class="line">	gender:<span class="literal">true</span>,</div><div class="line">	height:<span class="number">1.40</span>,</div><div class="line">	grade: <span class="literal">null</span>,</div><div class="line">	<span class="string">'middle-school'</span>: <span class="string">'\"W3C\" Middle School'</span>,</div><div class="line">	skills: [<span class="string">'JavaScript'</span>, <span class="string">'Java'</span>, <span class="string">'Python'</span>, <span class="string">'Lisp'</span>]</div><div class="line">&#125;;</div><div class="line"><span class="comment">//然后序列化该对象</span></div><div class="line"><span class="built_in">JSON</span>.stringify(xiaoming);</div><div class="line"><span class="comment">//产生整齐一点的JSON字符串可以这样写：</span></div><div class="line"><span class="built_in">JSON</span>.stringify(xiaoming,<span class="literal">null</span>,<span class="string">'  '</span>);</div><div class="line"><span class="comment">//第二个参数可以用一个数组/函数代替。以此产生用户所需的JSON字符串。</span></div></pre></td></tr></table></figure></p>
<p>2.反序列化，就是把JSON格式的字符串变成一个JS对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">JSON</span>.parse(<span class="string">'&#123;"name":"小明","age"：14&#125;'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">key,value</span>)</span>&#123;</div><div class="line">	<span class="keyword">if</span>(key===<span class="string">'name'</span>)&#123;</div><div class="line">  	<span class="keyword">return</span> value+<span class="string">'同学'</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> value;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><p>创建原型的方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Student = &#123;</div><div class="line">	name: <span class="string">'Robot'</span>,</div><div class="line">	height: <span class="number">1.2</span>,</div><div class="line">	run: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' is running...'</span>);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> xiaoming = &#123;</div><div class="line">	name: <span class="string">'小明'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">xiaoming.__proto__ = Student;</div></pre></td></tr></table></figure></p>
<p>但是，由于低版本的IE也无法使用<code>__proto__</code>。<code>Object.create()</code>方法可以传入一个原型对象，并创建一个基于该原型的新对象，但是新对象什么属性都没有，因此，我们可以编写一个函数来创建xiaoming：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStudent</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">	<span class="comment">// 基于Student原型创建一个新对象:</span></div><div class="line">	<span class="keyword">var</span> s = <span class="built_in">Object</span>.create(Student);</div><div class="line">	<span class="comment">// 初始化新对象:</span></div><div class="line">	s.name = name;</div><div class="line">	<span class="keyword">return</span> s;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> xiaoming = createStudent(<span class="string">'小明'</span>);</div><div class="line">xiaoming.run(); <span class="comment">// 小明 is running...</span></div><div class="line">xiaoming.__proto__ === Student; <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>####创建对象＊important<br>除了直接用{ … }创建一个对象外，JavaScript还可以用一种构造函数的方法来创建对象。它的用法是，先定义一个构造函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">	<span class="keyword">this</span>.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    	alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你会问，咦，这不是一个普通函数吗？</p>
<p>这确实是一个普通函数，但是在JavaScript中，可以用关键字new来调用这个函数，并返回一个对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> Student(<span class="string">'小明'</span>);</div><div class="line">xiaoming.name; <span class="comment">// '小明'</span></div><div class="line">xiaoming.hello(); <span class="comment">// Hello, 小明!</span></div></pre></td></tr></table></figure></p>
<p>注意，如果不写new，这就是一个普通函数，它返回undefined。但是，如果写了new，它就变成了一个构造函数，它绑定的this指向新创建的对象，并默认返回this，也就是说，不需要在最后写return this;。</p>
<p>新创建的xiaoming的原型链是：</p>
<pre><code>xiaoming ----&gt; Student.prototype ----&gt; Object.prototype ----&gt; null
</code></pre><p>prototype／constructor</p>
<p>用new Student()创建的对象还从原型上获得了一个constructor属性，它指向函数Student本身：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">xiaoming.constructor === Student.prototype.constructor; <span class="comment">// true</span></div><div class="line">Student.prototype.constructor === Student; <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.getPrototypeOf(xiaoming) === Student.prototype; <span class="comment">// true</span></div><div class="line"></div><div class="line">xiaoming <span class="keyword">instanceof</span> Student; <span class="comment">// true</span></div><div class="line"><span class="string">``</span><span class="string">`	</span></div><div class="line">![原型链](http://www.liaoxuefeng.com/files/attachments/00143529922671163eebb527bc14547ac11363bf186557d000/l)</div><div class="line">#### 原型继承＊＊important</div><div class="line">`<span class="string">``</span>javascript</div><div class="line"><span class="comment">// PrimaryStudent构造函数:</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrimaryStudent</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">	Student.call(<span class="keyword">this</span>, props);</div><div class="line">	<span class="keyword">this</span>.grade = props.grade || <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 空函数F:</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 把F的原型指向Student.prototype:</span></div><div class="line">F.prototype = Student.prototype;</div><div class="line"></div><div class="line"><span class="comment">// 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype:</span></div><div class="line">PrimaryStudent.prototype = <span class="keyword">new</span> F();</div><div class="line"></div><div class="line"><span class="comment">// 把PrimaryStudent原型的构造函数修复为PrimaryStudent:</span></div><div class="line">PrimaryStudent.prototype.constructor = PrimaryStudent;</div><div class="line"></div><div class="line"><span class="comment">// 继续在PrimaryStudent原型（就是new F()对象）上定义方法：</span></div><div class="line">PrimaryStudent.prototype.getGrade = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.grade;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 创建xiaoming:</span></div><div class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> PrimaryStudent(&#123;</div><div class="line">	name: <span class="string">'小明'</span>,</div><div class="line">	grade: <span class="number">2</span></div><div class="line">&#125;);</div><div class="line">xiaoming.name; <span class="comment">// '小明'</span></div><div class="line">xiaoming.grade; <span class="comment">// 2</span></div><div class="line"></div><div class="line"><span class="comment">// 验证原型:</span></div><div class="line">xiaoming.__proto__ === PrimaryStudent.prototype; <span class="comment">// true</span></div><div class="line">xiaoming.__proto__.__proto__ === Student.prototype; <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// 验证继承关系:</span></div><div class="line">xiaoming <span class="keyword">instanceof</span> PrimaryStudent; <span class="comment">// true</span></div><div class="line">xiaoming <span class="keyword">instanceof</span> Student; <span class="comment">// true</span></div><div class="line"><span class="string">``</span><span class="string">`	</span></div><div class="line">![图解](http://www.liaoxuefeng.com/files/attachments/001439872160923ca15925ec79f4692a98404ddb2ed5503000/l)</div><div class="line"></div><div class="line">注意，函数F仅用于桥接，我们仅创建了一个`<span class="keyword">new</span> F()<span class="string">`实例，而且，没有改变原有的Student定义的原型链。</span></div><div class="line"></div><div class="line">如果把继承这个动作用一个`inherits()<span class="string">`函数封装起来，还可以隐藏F的定义，并简化代码：</span></div><div class="line">`<span class="string">``</span>javascript</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherits</span>(<span class="params">Child, Parent</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">	F.prototype = Parent.prototype;</div><div class="line">	Child.prototype = <span class="keyword">new</span> F();</div><div class="line">	Child.prototype.constructor = Child;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个<code>inherits()</code>函数可以复用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = props.name || <span class="string">'Unnamed'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Student.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrimaryStudent</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">	Student.call(<span class="keyword">this</span>, props);</div><div class="line">	<span class="keyword">this</span>.grade = props.grade || <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 实现原型继承链:</span></div><div class="line">inherits(PrimaryStudent, Student);</div><div class="line"></div><div class="line"><span class="comment">// 绑定其他方法到PrimaryStudent原型:</span></div><div class="line">PrimaryStudent.prototype.getGrade = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.grade;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>JavaScript的原型继承实现方式就是：</p>
<ol>
<li><p>定义新的构造函数，并在内部用<code>call()</code>调用希望“继承”的构造函数，并绑定this；</p>
</li>
<li><p>借助中间函数F实现原型链继承，最好通过封装的inherits函数完成；</p>
</li>
<li><p>继续在新的构造函数的原型上定义新方法。</p>
</li>
</ol>
<h4 id="class继承"><a href="#class继承" class="headerlink" title="class继承"></a>class继承</h4><p>class从ES6开始正式被引入到JavaScript中。class的目的就是让定义类更简单。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line">	<span class="keyword">constructor</span>(name) &#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	hello() &#123;</div><div class="line">		alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="comment">//调用</span></div><div class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> Student(<span class="string">'小明'</span>);</div><div class="line">xiaoming.hello();</div><div class="line">	</div><div class="line"><span class="comment">//继承</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimaryStudent</span> <span class="keyword">extends</span> <span class="title">Student</span> </span>&#123;</div><div class="line">	<span class="keyword">constructor</span>(name, grade) &#123;</div><div class="line">		<span class="keyword">super</span>(name); <span class="comment">// 记得用super调用父类的构造方法!</span></div><div class="line">		<span class="keyword">this</span>.grade = grade;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	myGrade() &#123;</div><div class="line">		alert(<span class="string">'I am at grade '</span> + <span class="keyword">this</span>.grade);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><h4 id="浏览器对象"><a href="#浏览器对象" class="headerlink" title="浏览器对象"></a>浏览器对象</h4><ul>
<li><p>window</p>
</li>
<li><p>navigator</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">alert(<span class="string">'appName = '</span> + navigator.appName + <span class="string">'\n'</span> +</div><div class="line">	<span class="string">'appVersion = '</span> + navigator.appVersion + <span class="string">'\n'</span> +</div><div class="line">	<span class="string">'language = '</span> + navigator.language + <span class="string">'\n'</span> +</div><div class="line">	<span class="string">'platform = '</span> + navigator.platform + <span class="string">'\n'</span> +</div><div class="line">	<span class="string">'userAgent = '</span> + navigator.userAgent);</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><em>请注意</em></strong>，navigator的信息可以很容易地被用户修改，所以JavaScript读取的值不一定是正确的。很多初学者为了针对不同浏览器编写不同的代码，喜欢用if判断浏览器版本，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> width;</div><div class="line"><span class="keyword">if</span> (getIEVersion(navigator.userAgent) &lt; <span class="number">9</span>) &#123;</div><div class="line">	width = <span class="built_in">document</span>.body.clientWidth;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">	width = <span class="built_in">window</span>.innerWidth;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但这样既可能判断不准确，也很难维护代码。正确的方法是充分利用JavaScript对不存在属性返回undefined的特性，直接用短路运算符||计算：</p>
<pre><code>var width = window.innerWidth || document.body.clientWidth;
</code></pre><ul>
<li><p>screen</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">screen.width：屏幕宽度，以像素为单位；</div><div class="line">screen.height：屏幕高度，以像素为单位；</div><div class="line">screen.colorDepth：返回颜色位数，如<span class="number">8</span>、<span class="number">16</span>、<span class="number">24</span>。</div></pre></td></tr></table></figure>
</li>
<li><p>location</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">location.protocol; <span class="comment">// 'http'</span></div><div class="line">location.host; <span class="comment">// 'www.example.com'</span></div><div class="line">location.port; <span class="comment">// '8080'</span></div><div class="line">location.pathname; <span class="comment">// '/path/index.html'</span></div><div class="line">location.search; <span class="comment">// '?a=1&amp;b=2'</span></div><div class="line">location.hash; <span class="comment">// 'TOP'</span></div><div class="line">location.assign(<span class="string">''</span>);<span class="comment">//加载一个新页面</span></div><div class="line">location.reload();<span class="comment">//重新加载当前页面</span></div></pre></td></tr></table></figure>
</li>
<li><p>document</p>
<ul>
<li>document.getElementById()</li>
<li>document.getElementsByTagName()</li>
<li><p>document.cookie; // ‘v=123; remember=true; prefer=zh’</p>
<p>  <em>Cookie是由服务器发送的key-value标示符。因为HTTP协议是无状态的，但是服务器要区分到底是哪个用户发过来的请求，就可以用Cookie来区分。当一个用户成功登录后，服务器发送一个Cookie给浏览器，例如user=ABC123XYZ(加密的字符串)…，此后，浏览器访问该网站时，会在请求头附上这个Cookie，服务器根据Cookie即可区分出用户。<br>Cookie还可以存储网站的一些设置，例如，页面显示的语言等等。</em></p>
<p>JavaScript可以通过document.cookie读取到当前页面的Cookie：</p>
<p>  document.cookie; // ‘v=123; remember=true; prefer=zh’<br>由于JavaScript能读取到页面的Cookie，而用户的登录信息通常也存在Cookie中，这就造成了巨大的安全隐患，这是因为在HTML页面中引入第三方的JavaScript代码是允许的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">   		<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://www.foo.com/jquery.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">	...</div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>如果引入的第三方的JavaScript中存在恶意代码，则www.foo.com网站将直接获取到www.example.com网站的用户登录信息。</p>
<pre><code>为了解决这个问题，服务器在设置Cookie时可以使用httpOnly，设定了httpOnly的Cookie将不能被JavaScript读取。这个行为由浏览器实现，主流浏览器均支持httpOnly选项，IE从IE6 SP1开始支持。

为了确保安全，服务器端在设置Cookie时，应该始终坚持使用httpOnly。
</code></pre><ul>
<li><p>history</p>
<p>   任何时候都不建议用</p>
</li>
</ul>
<h4 id="操作dom两种方法：document-get和queryselector"><a href="#操作dom两种方法：document-get和queryselector" class="headerlink" title="操作dom两种方法：document.get和queryselector"></a>操作dom两种方法：document.get和queryselector</h4><p>方法一<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回ID为'test'的节点：</span></div><div class="line"><span class="keyword">var</span> test = <span class="built_in">document</span>.getElementById(<span class="string">'test'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 先定位ID为'test-table'的节点，再返回其内部所有tr节点：</span></div><div class="line"><span class="keyword">var</span> trs = <span class="built_in">document</span>.getElementById(<span class="string">'test-table'</span>).getElementsByTagName(<span class="string">'tr'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 先定位ID为'test-div'的节点，再返回其内部所有class包含red的节点：</span></div><div class="line"><span class="keyword">var</span> reds = <span class="built_in">document</span>.getElementById(<span class="string">'test-div'</span>).getElementsByClassName(<span class="string">'red'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 获取节点test下的所有直属子节点:</span></div><div class="line"><span class="keyword">var</span> cs = test.children;</div><div class="line"></div><div class="line"><span class="comment">// 获取节点test下第一个、最后一个子节点：</span></div><div class="line"><span class="keyword">var</span> first = test.firstElementChild;</div><div class="line"><span class="keyword">var</span> last = test.lastElementChild;</div></pre></td></tr></table></figure></p>
<p>方法二<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 通过querySelector获取ID为q1的节点：</span></div><div class="line"><span class="keyword">var</span> q1 = <span class="built_in">document</span>.querySelector(<span class="string">'#q1'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 通过querySelectorAll获取q1节点内的符合条件的所有节点：</span></div><div class="line"><span class="keyword">var</span> ps = q1.querySelectorAll(<span class="string">'div.highlighted &gt; p'</span>);</div></pre></td></tr></table></figure></p>
<h5 id="更新dom"><a href="#更新dom" class="headerlink" title="更新dom"></a>更新dom</h5><ul>
<li><p>修改innerhtml属性，要注意对字符编码来避免XSS攻击</p>
</li>
<li><p>修改innertext和innercontent属性，确保无法设置html标签</p>
</li>
<li><p>修改css（DOM节点的style属性对应所有的CSS，可以直接获取或设置。因为CSS允许<code>font-size</code>这样的名称，但它并非JavaScript有效的属性名，所以需要在JavaScript中改写为驼峰式命名<code>fontSize</code>）</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取&lt;p id="p-id"&gt;...&lt;/p&gt;</span></div><div class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">'p-id'</span>);</div><div class="line"><span class="comment">// 设置CSS:</span></div><div class="line">p.style.color = <span class="string">'#ff0000'</span>;</div><div class="line">p.style.fontSize = <span class="string">'20px'</span>;</div><div class="line">p.style.paddingTop = <span class="string">'2em'</span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="插入dom"><a href="#插入dom" class="headerlink" title="插入dom"></a>插入dom</h5><p>appendChild<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> d = <span class="built_in">document</span>.createElement(<span class="string">'style'</span>);</div><div class="line">d.setAttribute(<span class="string">'type'</span>, <span class="string">'text/css'</span>);</div><div class="line">d.innerHTML = <span class="string">'p &#123; color: red &#125;'</span>;</div><div class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(d);</div></pre></td></tr></table></figure></p>
<p>insertBefore</p>
<p><code>parentElement.insertBefore(newElement, referenceElement);</code>，子节点会插入到referenceElement之前。</p>
<p>假定我们要把Haskell插入到Python之前：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"list"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"java"</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"python"</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"scheme"</span>&gt;</span>Scheme<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>可以这么写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span></div><div class="line">	list = <span class="built_in">document</span>.getElementById(<span class="string">'list'</span>),</div><div class="line">	ref = <span class="built_in">document</span>.getElementById(<span class="string">'python'</span>),</div><div class="line">	haskell = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</div><div class="line">haskell.id = <span class="string">'haskell'</span>;</div><div class="line">haskell.innerText = <span class="string">'Haskell'</span>;</div><div class="line">list.insertBefore(haskell, ref);</div><div class="line"><span class="string">``</span><span class="string">`	</span></div><div class="line">##### 删除dom</div><div class="line">先获得父节点，然后removechild</div><div class="line">`<span class="string">``</span>javascript</div><div class="line"><span class="comment">// 拿到待删除节点:</span></div><div class="line"><span class="keyword">var</span> self = <span class="built_in">document</span>.getElementById(<span class="string">'to-be-removed'</span>);</div><div class="line"><span class="comment">// 拿到父节点:</span></div><div class="line"><span class="keyword">var</span> parent = self.parentElement;</div><div class="line"><span class="comment">// 删除:</span></div><div class="line"><span class="keyword">var</span> removed = parent.removeChild(self);</div><div class="line">removed === self; <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p><em>注意到删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置。</em></p>
<p>当你遍历一个父节点的子节点并进行删除操作时，要注意，children属性是一个只读属性，并且它在子节点变化时会实时更新。</p>
<h4 id="操作表单"><a href="#操作表单" class="headerlink" title="操作表单"></a>操作表单</h4><p>HTML5新增了大量标准控件，常用的包括date、datetime、datetime-local、color等，它们都使用<code>&lt;input&gt;</code>标签：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"date"</span> <span class="attr">value</span>=<span class="string">"2015-07-01"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"datetime-local"</span> <span class="attr">value</span>=<span class="string">"2015-07-01T02:03:04"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"color"</span> <span class="attr">value</span>=<span class="string">"#ff0000"</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>提交表单：</p>
<ul>
<li><p><code>&lt;form&gt;</code>的<code>submit()</code>方法</p>
  <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"test-form"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"test"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"doSubmitForm()"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSubmitForm</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">'test-form'</span>);</div><div class="line">	<span class="comment">// 可以在此修改form的input...</span></div><div class="line">	<span class="comment">// 提交form:</span></div><div class="line">	form.submit();</div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>响应<code>&lt;form&gt;</code>本身的<code>onsubmit</code>事件，在提交form时作修改：</p>
  <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">	<span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"test-form"</span> <span class="attr">onsubmit</span>=<span class="string">"return checkForm()"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"test"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">form</span>&gt;</span></div><div class="line"></div><div class="line">	<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">checkForm</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">'test-form'</span>);</div><div class="line">		<span class="comment">// 可以在此修改form的input...</span></div><div class="line">		<span class="comment">// 继续下一步:</span></div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="tag">&lt;/<span class="name">script</span>&gt;</span> </div><div class="line">	```	</div><div class="line">***密码MD5加密***</div><div class="line">```html	</div><div class="line"><span class="comment">&lt;!-- HTML --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"login-form"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">onsubmit</span>=<span class="string">"return checkForm()"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"username"</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">id</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkForm</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> pwd = <span class="built_in">document</span>.getElementById(<span class="string">'password'</span>);</div><div class="line">	<span class="comment">// 把用户输入的明文变为MD5:</span></div><div class="line">	pwd.value = toMD5(pwd.value);</div><div class="line">	<span class="comment">// 继续下一步:</span></div><div class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>这个做法看上去没啥问题，但用户输入了口令提交时，口令框的显示会突然从几个<em>变成32个</em>（因为MD5有32个字符）。</p>
<p>要想不改变用户的输入，可以利用<code>&lt;input type=&quot;hidden&quot;&gt;</code>实现：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- HTML --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"login-form"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">onsubmit</span>=<span class="string">"return checkForm()"</span>&gt;</span></div><div class="line">   	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"username"</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span></div><div class="line">   	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">id</span>=<span class="string">"input-password"</span>&gt;</span></div><div class="line">   	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">id</span>=<span class="string">"md5-password"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span></div><div class="line">   	<span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkForm</span>(<span class="params"></span>) </span>&#123;</div><div class="line">   	<span class="keyword">var</span> input_pwd = <span class="built_in">document</span>.getElementById(<span class="string">'input-password'</span>);</div><div class="line">   	<span class="keyword">var</span> md5_pwd = <span class="built_in">document</span>.getElementById(<span class="string">'md5-password'</span>);</div><div class="line">   	<span class="comment">// 把用户输入的明文变为MD5:</span></div><div class="line">   	md5_pwd.value = toMD5(input_pwd.value);</div><div class="line">   	<span class="comment">// 继续下一步:</span></div><div class="line">   	<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h4 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h4><p>在HTML表单中，可以上传文件的唯一控件就是<code>&lt;input type=&quot;file&quot;&gt;</code>。</p>
<p>注意：当一个表单包含<code>&lt;input type=&quot;file&quot;&gt;</code>时，表单的enctype必须指定为multipart/form-data，method必须指定为post，浏览器才能正确编码并以multipart/form-data格式发送表单的数据。</p>
<p>出于安全考虑，浏览器只允许用户点击<code>&lt;input type=&quot;file&quot;&gt;</code>来选择本地文件，用JavaScript对<code>&lt;input type=&quot;file&quot;&gt;</code>的value赋值是没有任何效果的。当用户选择了上传某个文件后，JavaScript也无法获得该文件的真实路径</p>
<p>但是js可以在提交表单时对文件扩展名做检查<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = <span class="built_in">document</span>.getElementById(<span class="string">'test-file-upload'</span>);</div><div class="line"><span class="keyword">var</span> filename = f.value; <span class="comment">// 'C:\fakepath\test.png'</span></div><div class="line"><span class="keyword">if</span> (!filename || !(filename.endsWith(<span class="string">'.jpg'</span>) || filename.endsWith(<span class="string">'.png'</span>) || filename.endsWith(<span class="string">'.gif'</span>))) &#123;</div><div class="line">   	alert(<span class="string">'Can only upload image file.'</span>);</div><div class="line">   	<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>HTML5的File API提供了File和FileReader两个主要对象，可以获得文件信息并读取文件。</p>
<p>下面的例子演示了如何读取用户选取的图片文件，并在一个<div>中预览图像：</div></p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span></div><div class="line">   	fileInput = <span class="built_in">document</span>.getElementById(<span class="string">'test-image-file'</span>),</div><div class="line">   	info = <span class="built_in">document</span>.getElementById(<span class="string">'test-file-info'</span>),</div><div class="line">   	preview = <span class="built_in">document</span>.getElementById(<span class="string">'test-image-preview'</span>);</div><div class="line"><span class="comment">// 监听change事件:</span></div><div class="line">fileInput.addEventListener(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">   	<span class="comment">// 清除背景图片:</span></div><div class="line">   	preview.style.backgroundImage = <span class="string">''</span>;</div><div class="line">   	<span class="comment">// 检查文件是否选择:</span></div><div class="line">   	<span class="keyword">if</span> (!fileInput.value) &#123;</div><div class="line">       	info.innerHTML = <span class="string">'没有选择文件'</span>;</div><div class="line">       	<span class="keyword">return</span>;</div><div class="line">   	&#125;</div><div class="line">   	<span class="comment">// 获取File引用:</span></div><div class="line">   	<span class="keyword">var</span> file = fileInput.files[<span class="number">0</span>];</div><div class="line">   	<span class="comment">// 获取File信息:</span></div><div class="line">   	info.innerHTML = <span class="string">'文件: '</span> + file.name + <span class="string">'&lt;br&gt;'</span> +</div><div class="line">                    	<span class="string">'大小: '</span> + file.size + <span class="string">'&lt;br&gt;'</span> +</div><div class="line">                    	<span class="string">'修改: '</span> + file.lastModifiedDate;</div><div class="line">   	<span class="keyword">if</span> (file.type !== <span class="string">'image/jpeg'</span> &amp;&amp; file.type !== <span class="string">'image/png'</span> &amp;&amp; file.type !== <span class="string">'image/gif'</span>) &#123;</div><div class="line">       	alert(<span class="string">'不是有效的图片文件!'</span>);</div><div class="line">       	<span class="keyword">return</span>;</div><div class="line">   	&#125;</div><div class="line">   	<span class="comment">// 读取文件:</span></div><div class="line">   	<span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</div><div class="line">   	reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">       	<span class="keyword">var</span></div><div class="line">           	data = e.target.result; <span class="comment">// 'data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...'            </span></div><div class="line">       	preview.style.backgroundImage = <span class="string">'url('</span> + data + <span class="string">')'</span>;</div><div class="line">   	&#125;;</div><div class="line">   	<span class="comment">// 以DataURL的形式读取文件:</span></div><div class="line">   	reader.readAsDataURL(file);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><p><strong><em>回调</em></strong></p>
<p>上面的代码还演示了JavaScript的一个重要的特性就是单线程执行模式。在JavaScript中，浏览器的JavaScript执行引擎在执行JavaScript代码时，总是以单线程模式执行，也就是说，任何时候，JavaScript代码都不可能同时有多于1个线程在执行。</p>
<p>你可能会问，单线程模式执行的JavaScript，如何处理多任务？</p>
<p>在JavaScript中，执行多任务实际上都是异步调用，比如上面的代码：</p>
<pre><code>reader.readAsDataURL(file);
</code></pre><p>就会发起一个异步操作来读取文件内容。因为是异步操作，所以我们在JavaScript代码中就不知道什么时候操作结束，因此需要先设置一个回调函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">   	<span class="comment">// 当文件读取完成后，自动调用此函数:</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>当文件读取完成后，JavaScript引擎将自动调用我们设置的回调函数。执行回调函数时，文件已经读取完毕，所以我们可以在回调函数内部安全地获得文件内容。</p>
<h4 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h4><p>AJAX请求是异步执行的，也就是说，要通过回调函数获得响应。</p>
<p>在现代浏览器上写AJAX主要依靠XMLHttpRequest对象：<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">success</span>(<span class="params">text</span>) </span>&#123;</div><div class="line">   	<span class="keyword">var</span> textarea = <span class="built_in">document</span>.getElementById(<span class="string">'test-response-text'</span>);</div><div class="line">   	textarea.value = text;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params">code</span>) </span>&#123;</div><div class="line">   	<span class="keyword">var</span> textarea = <span class="built_in">document</span>.getElementById(<span class="string">'test-response-text'</span>);</div><div class="line">   	textarea.value = <span class="string">'Error code: '</span> + code;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest(); <span class="comment">// 新建XMLHttpRequest对象</span></div><div class="line"></div><div class="line">request.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 状态发生变化时，函数被回调</span></div><div class="line">   	<span class="keyword">if</span> (request.readyState === <span class="number">4</span>) &#123; <span class="comment">// 成功完成</span></div><div class="line">       	<span class="comment">// 判断响应结果:</span></div><div class="line">       	<span class="keyword">if</span> (request.status === <span class="number">200</span>) &#123;</div><div class="line">           	<span class="comment">// 成功，通过responseText拿到响应的文本:</span></div><div class="line">           	<span class="keyword">return</span> success(request.responseText);</div><div class="line">       	&#125; <span class="keyword">else</span> &#123;</div><div class="line">           	<span class="comment">// 失败，根据响应码判断失败原因:</span></div><div class="line">           	<span class="keyword">return</span> fail(request.status);</div><div class="line">       	&#125;</div><div class="line">   	&#125; <span class="keyword">else</span> &#123;</div><div class="line">       	<span class="comment">// HTTP请求还在继续...</span></div><div class="line">   	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 发送请求:</span></div><div class="line">request.open(<span class="string">'GET'</span>, <span class="string">'/api/categories'</span>);</div><div class="line">request.send();</div><div class="line"></div><div class="line">alert(<span class="string">'请求已发送，请等待响应...'</span>);</div></pre></td></tr></table></figure></p>
<h5 id="CORS？？？"><a href="#CORS？？？" class="headerlink" title="CORS？？？"></a>CORS？？？</h5><h4 id="Promise？？？"><a href="#Promise？？？" class="headerlink" title="Promise？？？"></a>Promise？？？</h4><h4 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas*"></a>Canvas<em>*</em></h4><p>Canvas的坐标以左上角为原点，水平向右为X轴，垂直向下为Y轴，以像素为单位，所以每个点都是非负整数。</p>
<p><code>CanvasRenderingContext2D</code>对象有若干方法来</p>
<h5 id="绘制图形："><a href="#绘制图形：" class="headerlink" title="绘制图形："></a>绘制图形：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span></div><div class="line">   	canvas = <span class="built_in">document</span>.getElementById(<span class="string">'test-shape-canvas'</span>),</div><div class="line">   	ctx = canvas.getContext(<span class="string">'2d'</span>);</div><div class="line">   	ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>); <span class="comment">// 擦除(0,0)位置大小为200x200的矩形，擦除的意思是把该区域变为透明</span></div><div class="line">	ctx.fillStyle = <span class="string">'#dddddd'</span>; <span class="comment">// 设置颜色</span></div><div class="line">	ctx.fillRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">130</span>, <span class="number">130</span>); <span class="comment">// 把(10,10)位置大小为130x130的矩形涂色</span></div><div class="line">	<span class="comment">// 利用Path绘制复杂路径:</span></div><div class="line">	<span class="keyword">var</span> path=<span class="keyword">new</span> Path2D();</div><div class="line">	path.arc(<span class="number">75</span>, <span class="number">75</span>, <span class="number">50</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI*<span class="number">2</span>, <span class="literal">true</span>);</div><div class="line">	path.moveTo(<span class="number">110</span>,<span class="number">75</span>);</div><div class="line">	path.arc(<span class="number">75</span>, <span class="number">75</span>, <span class="number">35</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI, <span class="literal">false</span>);</div><div class="line">	path.moveTo(<span class="number">65</span>, <span class="number">65</span>);</div><div class="line">	path.arc(<span class="number">60</span>, <span class="number">65</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI*<span class="number">2</span>, <span class="literal">true</span>);</div><div class="line">	path.moveTo(<span class="number">95</span>, <span class="number">65</span>);</div><div class="line">	path.arc(<span class="number">90</span>, <span class="number">65</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI*<span class="number">2</span>, <span class="literal">true</span>);</div><div class="line">	ctx.strokeStyle = <span class="string">'#0000ff'</span>;</div><div class="line">	ctx.stroke(path);</div></pre></td></tr></table></figure>
<h5 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h5><p>绘制文本就是在指定的位置输出文本，可以设置文本的字体、样式、阴影等，与CSS完全一致：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span></div><div class="line">   	canvas = <span class="built_in">document</span>.getElementById(<span class="string">'test-text-canvas'</span>),</div><div class="line">   	ctx = canvas.getContext(<span class="string">'2d'</span>);</div><div class="line">   	ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);</div><div class="line">	ctx.shadowOffsetX = <span class="number">2</span>;</div><div class="line">	ctx.shadowOffsetY = <span class="number">2</span>;</div><div class="line">	ctx.shadowBlur = <span class="number">2</span>;</div><div class="line">	ctx.shadowColor = <span class="string">'#666666'</span>;</div><div class="line">	ctx.font = <span class="string">'24px Arial'</span>;</div><div class="line">	ctx.fillStyle = <span class="string">'#333333'</span>;</div><div class="line">	ctx.fillText(<span class="string">'带阴影的文字'</span>, <span class="number">20</span>, <span class="number">40</span>);</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[我为什么要用Node.js?]]></title>
      <url>http://yoursite.com/2016/08/27/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8Node-js/</url>
      <content type="html"><![CDATA[<p><em>英文出处：<a href="https://www.toptal.com/nodejs/why-the-hell-would-i-use-node-js" target="_blank" rel="external">toptal</a>。</em><br>JavaScript 高涨的人气带来了很多变化，以至于如今使用其进行网络开发的形式也变得截然不同了。就如同在浏览器中一样，现在我们也可以在服务器上运行 JavaScript ，从前端跨越到后端，这样巨大的反差让人难以想象，因为仅仅在几年前 Javascript 还如同 Flash 或者 Java applet 那样嵌入网页在沙箱环境中运行。<br><img src="https://www.visualstudio.com/wp-content/uploads/2016/06/Nodejs-2-562x309@2x-op.png" alt=""><br><a id="more"></a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在深入Node.js之前，你可能需要阅读和了解使用跨栈式JavaScript（JavaScript across the stack）带来的好处，它统一了编程语言和数据格式（JSON），让你能最佳地重用开发人员资源。由于这更多的是关于 JavaScript 的特点，这里就不过多讨论它。但它确实是一个让人在开发环节中使用 Notode 的关键的优点。</p>
<p>正如维基百科 所说：“Node.js 是谷歌 V8 引擎、libuv平台抽象层 以及主体使用 Javscript 编写的核心库三者集合的一个包装外壳。” 除此之外，值得注意的是，Node.js 的作者瑞恩·达尔 (Ryan Dahl) 的目标是创建具有实时推送能力的网站。在 Node.js 中，他给了开发者一个使用事件驱动来实现异步开发的优秀解决方案。（注：V8是谷歌开发的，目前公认最快的 Javascript 解析引擎，libuv 是一个开源的、为 Node 定制而生的跨平台的异步 IO 库。）</p>
<p>简而言之：Node.js 在实时的 Web应用上采用了基于 WebSocket 的推送技术。这意味着什么样的革命性？Well，在经过了20多年的基于无状态的请求-返机制的无状态交互之后，我们终于有了实时的，双向连接的web应用，客户端和服务器端都可以发起通信，能够自由地交换数据。与此形成鲜明对比的是传统的 web响应模式，客户端总是主动发起通信而服务端被动返回。此外，这些都是基于运行在标准80端口上的开放Web组件（HTML、CSS和JS）。</p>
<p>可能有人会说，我们已经使用 Flash 和 Java Applet 的形式很多年了——但实际上，这些方式只是使用网络将数据传递到客户端上的沙箱环境。他们都是隔离运行的，而且经常操作到需要额外的权限之类的非标准端口。</p>
<p>凭借其独特的优势，Node.js的现在已经在许多著名公司的产品中起到了关键作用。</p>
<p>在这篇文章中，我们不仅将讨论这些优势是如何实现的，而且也会讨论为什么你使用 Node.js 来替代一些经典的Web应用程序模型。</p>
<h2 id="Node-js-是如何工作的？"><a href="#Node-js-是如何工作的？" class="headerlink" title="Node.js 是如何工作的？"></a>Node.js 是如何工作的？</h2><p>Node.js 的主要思路是：使用非阻塞的，事件驱动的 I/O 操作来保持在处理跨平台 (across distributed devices) 数据密集型实时应用时的轻巧高效。这听起来有点绕口。</p>
<p>它的真正含义是，Node.js 不是一个即将主导Web开发的世界的银弹级的平台。相反，它是一个满足特别需求的平台。你肯定不会希望使用 Node.js 去做 CPU密集型操作。事实上，使用它进行繁重的计算等于摒弃 Node 几乎所有的优点。Node 真正的亮点在于建设高性能，高扩展性的互联网应用——因为它能够处理庞大的并且高吞吐量的并发连接。</p>
<p>它的工作原理是相当有趣的。传统的网络服务技术，是每个新增一个连接（请求）便生成一个新的线程，这个新的线程会占用系统内存，最终会占掉所有的可用内存。而 Node.js 仅仅只运行在一个单线程中，使用非阻塞的异步 I/O 调用，所有连接都由该线程处理，在 libuv 的加分下，可以允许其支持数万并发连接（全部挂在该线程的事件循环中）。</p>
<p><img src="http://jbcdn2.b0.upaiyun.com/2013/12/toptal-blog-1_B.png" alt="toptal-blog-1_B"></p>
<p>做一个简单的计算: 假设是普通的Web程序，新接入一个连接会占用 2M 的内存，在有 8GB RAM的系统上运行时, 算上线程之间上下文切换的成本，并发连接的最大理论值则为 4000 个。这是在传统 Web服务端技术下的处理情况。而 Node.js 则达到了约 1M 一个并发连接的拓展级别.</p>
<p>当然，在所有客户端的请求共享单一线程时也会有问题, 这也是一个编写 Node.js 应用的潜在缺陷. 首先, 大量的计算可能会使得 Node 的单线程暂时失去反应, 并导致所有的其他客户端的请求一直阻塞, 直到计算结束才恢复正常。 其次，开发人员需要非常小心，不要让一个 Exception 阻塞核心的事件循环，因为这将导致 Node.js 实例的终止（实际上就是程序崩溃）。（ 笔者注：如 PHP 中某个页面挂掉是不会影响网站运行的，但是 Nodejs 是一个线程一个线程来处理所有的链接，所以不论是计算卡了或者是被异常阻塞了都可能会影响到其他所有的链接。解决方案在稍后讨论。）</p>
<p>用来避免异常抛出时中断进程的方法是将异常使用回调传递出去（而不是抛出他们，就像在其他环境中一样）。即使一些未处理的异常阻塞了程序，依旧有多种应对的解决方案，而且也有很多可用于监视 Node 进程来执行必要的崩溃后恢复工作的策略和工具（虽然你将无法恢复用户的 Session ），最常见的是使用 Forever 模块，或者采用其他的外部系统工具如 upstart and monit。</p>
<h2 id="NPM-The-Node-Package-Manager"><a href="#NPM-The-Node-Package-Manager" class="headerlink" title="NPM: The Node Package Manager"></a>NPM: The Node Package Manager</h2><p>当我们讨论 Node.js 的时候，一个绝对不应该忽略地方就是默认内置的模块管理工具 —— NPM。 其灵感来源与 Ruby Gems（具有版本和依赖管理功能，可以通过在线资料库便捷安装可重用的组件的管理工具）。</p>
<p>一个完整的公用模块列表可以在 NPM 的网站上找到（<a href="https:://npmjs.org/" target="_blank" rel="external">https:://npmjs.org/</a>），或者通过使用与 Node.js 一同安装的 NPM CLI 工具放问到。该模块的生态系统向所有人开放，任何人都可以发布自己的模块，所有的模块都可以在 NPM 资料库中找到。你可以在 <a href="http://howtonode.org/introduction-to-npm" target="_blank" rel="external">http://howtonode.org/introduction-to-npm</a> 页面找到 NPM 的一个简要介绍（有点旧，但依旧能看）。</p>
<p>目前非常流行的一些 NPM 模块有：</p>
<ul>
<li><a href="http://expressjs.com/" target="_blank" rel="external">express</a> – Express.js,是一个简洁而灵活的 node.js Web应用框架, 并且已经是现在大多数 Node.js 应用的标准框架，你已经可以在很多 Node.js 的书籍中看到它了。</li>
<li><a href="https://github.com/senchalabs/connect#readme" target="_blank" rel="external">connect</a> – Connect 是一个 Node.js 的 HTTP 服务拓展框架，提供一个高性能的“插件”集合，以中间件闻名，是 Express 的基础部分之一。</li>
<li><a href="http://socket.io/" target="_blank" rel="external">socket.io</a> 和 <a href="https://github.com/sockjs" target="_blank" rel="external">sockjs</a> – 目前服务端最流行的两个 websocket 组件。</li>
<li><a href="http://jade-lang.com/" target="_blank" rel="external">Jade</a> – 流行的模板引擎之一，并且是 Express.js 的默认模板引擎。其灵感来源于 HAML。</li>
<li><a href="https://npmjs.org/package/mongodb" target="_blank" rel="external">mongo</a> 和 <a href="https://github.com/mafintosh/mongojs" target="_blank" rel="external">mongojs</a> – 封装了 MongoDB 的的各种 API，不过笔者平常工作用的是 <a href="http://mongoosejs.com/" target="_blank" rel="external">mongoose</a> 也很推荐。</li>
<li><a href="https://github.com/NodeRedis/node_redis" target="_blank" rel="external">redis</a> – Redis 的客户端函数库.</li>
<li><a href="https://npmjs.org/package/coffee-script" target="_blank" rel="external">coffee-script</a> – CoffeeScript 编译器，允许开发者使用 Coffee 来编写他们的 Node.js 程序。</li>
<li><a href="https://npmjs.org/package/underscore" target="_blank" rel="external">underscore</a> (<a href="https://lodash.com/" target="_blank" rel="external">lodash</a>, <a href="https://www.npmjs.com/package/lazy" target="_blank" rel="external">lazy</a>) – 最流行的 JavaScript 工具库 , 用于 Node.js 的封装包，以及两个采取略有不同的实现方法来获得更好性能的同行。</li>
<li><a href="https://www.npmjs.com/package/forever" target="_blank" rel="external">forever</a> – 可能是用来确保 node 脚本持续运行的最流行的工具。</li>
</ul>
<p>还有很多好的模块，这里就不一一列举了（希望没有冒犯到没列举的）。</p>
<h2 id="Node-js-应该用在什么地方"><a href="#Node-js-应该用在什么地方" class="headerlink" title="Node.js 应该用在什么地方"></a>Node.js 应该用在什么地方</h2><h3 id="聊天"><a href="#聊天" class="headerlink" title="聊天"></a>聊天</h3><p>聊天是最典型的多用户实时交互的应用。从 IRC 开始，有许多开源或者不开源的协议都运行在非标准端口上，而现在，使用 Node.js 则可以解决这些问题——在标准的80端口运行 WebSockets。</p>
<p>聊天应用程序是最能体现 Node.js 优点的例子：轻量级、高流量并且能良好的应对跨平台设备上运行密集型数据（虽然计算能力低）。同时，聊天也是一个非常值得学习的用例，因为它很简单，并且涵盖了目前为止一个典型的 Node.js 会用到的大部分解决方案。</p>
<p>让我们试着来描绘它如何工作。</p>
<p>在最简单的情况下，我们布置了一个聊天室在我们的网站上，用户可以在上面发消息，当然是一对多的形式。例如，假设总共有三个人连接到我们的网站上。</p>
<p>在服务端这边， 我们有一个使用 Express.js 搭建的简单站点，该站点实现了两件事 </p>
<ol>
<li>处理路径为 ‘/’ 的GET请求时，下发包括一个留言板以及一个发送信息的 ‘发送’ 按钮的页面 </li>
<li>一个监听客户端发送新消息的 websockets 服务。</li>
</ol>
<p>在客户端这边，我们有一个 HTML 页面，上面有个两个 js 方法，一个是用于触发事件的 “发送” 按钮，这会把把输入的消息通过 webscoket 发送，另一个方法是用 webscoket 在客户端上监听服务端来的推送（例如，其他用户发送的消息）。</p>
<p>当有一个客户端发送消息的时候，发生的事情是：</p>
<ol>
<li>浏览器上，点击发送按钮触发了 js 函数，将输入框中的文字通过 websocket 消息发送到服务器的 websocket 客户端（页面初始化加载的时候连接的）。</li>
<li>服务端的 websocket 组件收到 消息，然后通过广播方法转发到其他所有连接的客户端。</li>
<li>通过页面上运行的 websocket 客户端组件，所有的客户端都能收到这条推送的新消息。接着 js 处理函数可以把这个消息添加到文字框内。</li>
</ol>
<p> <img src="http://jbcdn2.b0.upaiyun.com/2013/12/toptal-blog-2_B.png" alt="img1"></p>
<p>这是一个最简单的例子。如果要更好的解决方案，你可以使用 Redis 数据库做一个简单的缓存。在一个更高级的解决方案中，你可能需要一个消息路由来专门处理消息队列，并且需要一个更强健的发送机制，比如发送的时候覆盖上暂时离线的用户或者为离线的注册用户存储尚未接收的消息等等。但是不论你做了怎么样的改进，Node.js 都将遵循一个基本原则：响应事件，处理多个并发连接，并保持流动性的用户体验。</p>
<h3 id="对象数据库接口（API-ON-TOP-OF-AN-OBJECT-DB）"><a href="#对象数据库接口（API-ON-TOP-OF-AN-OBJECT-DB）" class="headerlink" title="对象数据库接口（API ON TOP OF AN OBJECT DB）"></a>对象数据库接口（API ON TOP OF AN OBJECT DB）</h3><p>尽管，Node.js 确实非常擅长实时交互的应用，同时它也十分适合通过对象数据库（object DB）来查询数据（如 MongoDB）。以 JSON 格式存储的数据允许 Node.js 直接处理，不需要纠结数据转换和匹配的问题。</p>
<p>举个例子，如果你正在使用 Rails，你会将 JSON 数据转成 二进制的 model，当数据再被 Backbone.js, Angular.js 或者 jQuery AJAX 之类的调用又要转回 JSON。如果是 Nodejs 的话，你可以通过一个 REST API 简单的导出 JSON 对象以供客户端使用。另外，从数据库读写时候如果使用的是 MongoDB 的话，你也不用担心的 JSON 与任何数据之间的格式问题。总之，你可以避免多元的数据转换问题，不论是在客户端、服务端还是数据库。</p>
<h3 id="队列输入"><a href="#队列输入" class="headerlink" title="队列输入"></a>队列输入</h3><p>如果你正在接收一个高量并发的数据，你的数据库可能会成为你处理的瓶颈。正如上面的描述，Node.js 可以轻松的处理并发连接。 但是，由于数据库操作是一个阻塞的操作（在这种情况下），这就是麻烦的地方。Node.js的解决方案是，在数据真正的写入之前就承认客户端的数据是真实的。</p>
<p>用这种方法，在高负载的时候系统继续维持它的响应，这在当客户端不需要严格确认一个数据是否成功的被写入时特别有用。典型的例子包括：日志记录或者用户跟踪数据（user-tracking data）的记录，这会被分批处理并且在稍后才使用；同时也包括最终一致性（so, 常用于 NoSQL）可以接受，不需要立即反应的操作（例如 Facebook 上更新点赞的数目）。</p>
<p>数据通过某些缓存或者消息队列的基础组件（例如 RabbitMQ, ZeroMQ）进入队列，并且通过一个独立的数据库批量写入进程来一一消化，或者通过一个更高性能的计算密集型后端服务来进行处理。其他的语言/框架也可以实现相似的操作，但在相同的配置下是达不到 nodejs 的高吞吐量与高并发。</p>
<p><img src="http://jbcdn2.b0.upaiyun.com/2013/12/toptal-blog-3_B.png" alt="toptal-blog-3_B"></p>
<p>简单的说：使用 Node，你可以把数据库操作扔到一边并在稍后处理它们，假设他们成功了一样继续执行下去。（笔者注：在开发中通常的情况通常是，种耗时的操作通过回调函数来异步处理，主线程继续往下执行）</p>
<h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p>在较为传统的网络平台上，HTTP 的请求和响应更像是孤立的事件；然而事实上，他们都是数据流。这一观察结果在 Nodejs 上可以用来建立一些很酷的功能。因为数据通以流的形式接收，而我们可以在网站上在线处理正在上传中的文件。这样的话，就可以实现实时的音频和视频编码，以及在不同数据源之间进行代码（代理见下一段）。</p>
<p>（笔者注：Node 有代替如 apache 这样的 webserver 处理数据，所以开发者可以直接收到客户端一份一份上传的数据，并实时处理。上面这段话听起来有点抽象，不过各位可以简单的想象一下不需要开 YY 或者 QQ，打开网页就能进行语音视频的功能。）</p>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>Node.js 可以通过异步的方式处理大量的并发连接，所以很容易作为服务端的代理来使用。这在与不同响应时间的不同服务之间进行代理，或者是收集来自多个来源的数据时尤其有用。</p>
<p>举个例子：考虑一个服务器端的应用程序和第三方资源进行通信以更新自不同来源的数据，或者将服务端上的一些图像和视频资源存储到第三方云服务。</p>
<p>虽然专用代理服务器确实存在，但是如果你还没有专用的代理服务器，或者你需要一个本地开发的解决方案，那么使用 Node 来做代理可能是更好的选择。关于这个解决方案，我的意思是指当你在开发的时候，你可以使用Node.js的开发环境搭建一个服务来处理对资源和代理的请求，而在生产环境下，你可以使用专用的代理服务（比如nginx，HAProxy等）来处理这些交互。</p>
<h3 id="股票操盘手的仪表盘"><a href="#股票操盘手的仪表盘" class="headerlink" title="股票操盘手的仪表盘"></a>股票操盘手的仪表盘</h3><p>让我们继续讨论应用程序这块。实时网络的解决方案可以很轻松的实现证券交易软件——用于跟踪股票的价格，执行计算、做技术分析，同时生成报表。</p>
<p>使用一个实时的的基于网页的解决方案，将会允许操盘手轻松的切换工作软件以及工作地点。相信不久，我们或许会在 佛罗里达州、伊维萨岛又或者是巴厘岛的海滩上看到他们。</p>
<h3 id="应用监听仪盘表"><a href="#应用监听仪盘表" class="headerlink" title="应用监听仪盘表"></a>应用监听仪盘表</h3><p>另一种常见的用例中，使用 Node+Web+Socket 非常适合：跟踪网站访问者并且可视化实时它们之间的实时交互。 （如果你有兴趣，可以去看看 Hummingbird）</p>
<p>你可能需要采集用户的实时状态, 或者甚至当他们到达渠道中某个特定的点时, 打开一个交流频道， 通过有针对性的互动介绍移动到下一个阶段. （如果你感兴趣的话，推荐你看看 CANDDi）</p>
<p>想象一下，如果你知道你的访客的实时操作，并能够形象化地看到他们的交互，这将对你的业务带来多大的提升。随着实时的、双向 socket 通信的 Node.js ，现在你可以做到了。</p>
<h3 id="系统监控仪表"><a href="#系统监控仪表" class="headerlink" title="系统监控仪表"></a>系统监控仪表</h3><p>现在，让我们看看事情的基础设施方面。想象一下，比如，希望为其用户提供服务监控页面（例如，GitHub上的状态页）的 SaaS 运营商 。通过 Node.js 的事件循环，我们可以创建一个基于 Web 的功能强大的仪表板，以异步方式检查服务状态并且使用的 WebSockets 将数据推送到客户端。</p>
<p>内部（公司内部）和公共服务的状态都可以使用该项技术实现实时的上报。让我们把这一想法延伸的远一点，试着想象一个电信运营商中网络运营中心（NOC）的监控应用，云/网络/服务器运营商，或者一些金融机构，全都运行在这个由 Node.js 和 WebSocket 组成的应用上，而不是 Java 和/或 Java Applet。</p>
<p>注意：不要尝试使用 Node 打造硬实时系统（即，响应时间要求一致的系统）。 Erlang是可能是该类应用程序的更好的选择。</p>
<h2 id="什么地方可以使用-Node-js"><a href="#什么地方可以使用-Node-js" class="headerlink" title="什么地方可以使用 Node.js"></a>什么地方可以使用 Node.js</h2><h3 id="服务端-WEB-应用"><a href="#服务端-WEB-应用" class="headerlink" title="服务端 WEB 应用"></a>服务端 WEB 应用</h3><p>通过 Node.js 使用 Express.js 也可以用来创建服务端上的典型的网页应用。然而，虽然有可能，使用 Node.js 来进行请求+响应的形式来呈现 HTML 并不是最典型的用例。有人赞成也有人反对这一做法。这里有一些看法以供参考:</p>
<p><strong>优点：</strong></p>
<ul>
<li>如果你不需要进行 CPU密集型计算，你可以从头到尾甚至是数据库（比如 MongoDB）都使用 Javascript 来开发。这显著地减轻了开发工序（包括成本）。</li>
<li>对于一个使用 Node.js 作为服务端的单页应用或者 websocket 应用，爬虫可以收到一个完全 HTML 呈现的响应，这是更为SEO友好的。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>任何CPU密集型的计算都将阻碍 Node.js 的反应，所以使用多线程的平台是一个更好的方法。或者，您也可以尝试向外扩展的计算[*]。</li>
<li>Node.js 使用关系型数据库依旧十分痛苦（详细见下方）。拜托了，如果你想执行关系型数据操作，请考虑别的环境：Rails， Django 甚至 ASP.NET MVC 。。。。</li>
</ul>
<p><strong>另一种解决方案是，为这些CPU密集型的计算建立一个高度可扩展的MQ支持的环境与后端处理，以保持 Node 作为一个前台专员来异步处理客户端请求。</strong></p>
<h2 id="Node-js-不应该在什么地方使用"><a href="#Node-js-不应该在什么地方使用" class="headerlink" title="Node.js 不应该在什么地方使用"></a>Node.js 不应该在什么地方使用</h2><h3 id="使用关系型数据库的服务端-WEB-应用"><a href="#使用关系型数据库的服务端-WEB-应用" class="headerlink" title="使用关系型数据库的服务端 WEB 应用"></a>使用关系型数据库的服务端 WEB 应用</h3><p>对比 Node.js 上的 Express.js 和 Ruby on Rails，当你使用关系型数据库的时候请毫不犹豫的选择后者。</p>
<p>Node.js 的关系数据库工具仍处于早期阶段，目前还没有成熟到让人能够愉快地使用它。而与此同时，Rails天生自带了数据访问组件，连同DB schema迁移的支持工具和一些Gems（一语双关，一指这些如同珍宝的工具，二指ruby的gems程序包）。Rails和它的搭档框架们拥有非常成熟且被证明了的活动记录（Active Record）或数据映射（Data Mapper）的数据访问层的实现，而这些是当你在使用纯JavaScript来复制这些应用的时候会非常想要使用的东西。</p>
<p>不过，如果你真的倾向于全部使用 JS（并且做好可能抓狂的准备），那么请继续关注 Sequelize 和 Node ORM2 ，虽然这两者仍然不成熟的，但他们最终会迎头赶上。</p>
<p><strong>使用 Node 光是作为前端而 Rails 做后端来连接关系型数据库，这是完全有可能也并不少见的。（笔者注：国外有种说法，PHP这一类程序员也可以算作是前端）</strong></p>
<h3 id="繁重的服务端的计算和处理"><a href="#繁重的服务端的计算和处理" class="headerlink" title="繁重的服务端的计算和处理"></a>繁重的服务端的计算和处理</h3><p>当涉及到大量的计算，Node.js 就不是最佳的解决方案。你肯定不希望使用 Node.js 建立一个斐波那契数的计算服务。一般情况下，任何 CPU密集型操作 会削弱掉 Node通过事件驱动， 异步 I/O 模型等等带来的在吞吐量上的优势，因为当线程被非异步的高计算量占用时任何传入的请求将被阻塞。</p>
<p>正如前面所说，Node.js 是单线程的，只使用一个单一的CPU核心。至于，涉及到服务器上多核并发处理，Node 的核心团队已经使用 cluster 模块的形式在这一方面做了一些工作 (参考：<a href="http://nodejs.org/api/cluster.html)。当然，您也可以很容易的通过" target="_blank" rel="external">http://nodejs.org/api/cluster.html)。当然，您也可以很容易的通过</a> nginx 的反向代理运行多个 Node.js 的服务器实例来避免单一线程阻塞的问题。</p>
<p>关于集群(clustering) ，你应该将所有繁重的计算转移到更合适的语言写的后台进程来处理，同时让他们通过像 RabbitMQ 那样通过消息队列服务器来进行通信。</p>
<p>即使你的后台处理可能最初运行在同一台服务器上时看不出什么优点，但是这样的做法具有非常高的可扩展性的潜力。这些后台处理服务可以容易地分割出去，作为单独的 worker 服务器，而不需要配置入口 web服务器的负载。</p>
<p>当然，你也可以在其他语言平台上用同样的方法，但使用 Node.js 你可以得到很高的吞吐量，每个请求都作为一个小任务非常迅速和高效地处理，这一点我们已经讨论过了。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>我们已经从理论到实践讨论过 Node.js 了，从它的目标和野心，到其优点和缺点。在 Node.js 的开发中99%的问题是由误用阻塞操作而造成的。</p>
<p>请记住：Node.js 从来不是用于解决大规模计算问题而创建的。它的出现是为了解决大规模I/O 的问题，并且在这一点上做的非常好。</p>
<p>综上，如果你项目需求中不包含CPU密集型操作，也不需要访问任何阻塞的资源，那么你就可以利用的 Node.js 的优点，尽情的享受快速、可扩展的网络应用。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Virtualenv的使用]]></title>
      <url>http://yoursite.com/2016/08/02/virtualenv%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h3 id="我个人使用的目的：便于不同版本python开发"><a href="#我个人使用的目的：便于不同版本python开发" class="headerlink" title="我个人使用的目的：便于不同版本python开发"></a>我个人使用的目的：便于不同版本python开发</h3><h5 id="安装"><a href="#安装" class="headerlink" title="安装:"></a>安装:</h5><pre><code>$ sudo apt-get install python-virtualenv
</code></pre><h5 id="建存放目录："><a href="#建存放目录：" class="headerlink" title="建存放目录："></a>建存放目录：</h5><pre><code>$ mkdir testvirtual
</code></pre><h5 id="创建虚拟环境（python3下的）："><a href="#创建虚拟环境（python3下的）：" class="headerlink" title="创建虚拟环境（python3下的）："></a>创建虚拟环境（python3下的）：</h5><pre><code>$ virtualenv -p python3 env1
</code></pre><h5 id="启动虚拟环境："><a href="#启动虚拟环境：" class="headerlink" title="启动虚拟环境："></a>启动虚拟环境：</h5><pre><code>$ cd env1
$ source ./bin/activate
</code></pre><h5 id="退出虚拟环境："><a href="#退出虚拟环境：" class="headerlink" title="退出虚拟环境："></a>退出虚拟环境：</h5><pre><code>$ deactivate
</code></pre><h5 id="可以直接在虚拟环境运行pip等"><a href="#可以直接在虚拟环境运行pip等" class="headerlink" title="可以直接在虚拟环境运行pip等"></a>可以直接在虚拟环境运行pip等</h5><pre><code>$ pip install xxx
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Git整理]]></title>
      <url>http://yoursite.com/2016/08/01/Git%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<p><div><img src="http://rogerdudler.github.io/git-guide/img/trees.png" style=""></div></p>
<h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><a id="more"></a>
<p><strong>一、创建库</strong></p>
<pre><code>git init &lt;库名&gt;
</code></pre><p><strong>二、创建分支</strong> (打开刚创建的库: cd &lt;库名&gt;)</p>
<pre><code>git branch &lt;分支名&gt;
</code></pre><p>注：如果创建分支失败，建立一个测试文本文件即可。</p>
<pre><code>1. git add .
2. git commit -a -m &quot;test&quot;
</code></pre><p><strong>三、切换分支</strong></p>
<pre><code>git checkout &lt;分支名&gt; 
</code></pre><p>该语句和上一个语句可以和起来用一个语句表示：</p>
<pre><code>git checkout -b &lt;分支名&gt;
</code></pre><p><strong>四、查看当前库所有分支</strong></p>
<pre><code>git branch
</code></pre><p><strong>五、分支合并</strong></p>
<p>比如，如果要将当前的分支develop，合并到主分支master<br>首先我们需要切换到master主分支：</p>
<pre><code>git checkout master
</code></pre><p>然后执行合并操作：</p>
<pre><code>git merge develop
</code></pre><p>如果有冲突，会提示你，调用<code>git status</code>查看冲突文件。 </p>
<p>解决冲突，然后调用<code>git add</code>或<code>git rm</code>将解决后的文件暂存。 </p>
<p>所有冲突解决后，<code>git commit</code> 提交更改。</p>
<p><strong>六、分支衍合</strong></p>
<p>分支衍合和分支合并的差别在于，分支衍合不会保留合并的日志，不留痕迹，而 分支合并则会保留合并的日志。 </p>
<p>要将开发中的分支develop，衍合到主分支master<br>首先切换的master分支：</p>
<pre><code>git checkout master
</code></pre><p>然后执行衍和操作：</p>
<pre><code>git rebase develop
</code></pre><p>如果有冲突，会提示你，调用<code>git status</code>查看冲突文件。 </p>
<p>解决冲突，然后调用<code>git add</code>或<code>git rm</code>将解决后的文件暂存。<br>所有冲突解决后，</p>
<pre><code>git rebase –continue 
</code></pre><p>提交更改。</p>
<p><strong>七、删除分支</strong></p>
<pre><code>git branch -d &lt;分支名&gt; 
</code></pre><p>如果该分支没有合并到主分支会报错，可以用以下命令强制删除</p>
<pre><code>git branch -D &lt;分支名&gt;
</code></pre><p><strong>八、删除库</strong></p>
<pre><code>rm -rf &lt;库名&gt;
</code></pre><h3 id="创建项目站点-demo"><a href="#创建项目站点-demo" class="headerlink" title="创建项目站点(demo)"></a>创建项目站点(demo)</h3><pre><code>$ git clone https://github.com/USERNAME/PROJECT.git
$ git checkout --orphan gh-pages
$ git rm -rf .（可选，在里面放要展示的demo）
$ git add .
$ git commit -a -m &quot;First pages commit&quot;
$ git push origin gh-pages
$ 或者
$ git push -u origin HEAD
</code></pre><h4 id="使用Git在本地创建一个项目的过程"><a href="#使用Git在本地创建一个项目的过程" class="headerlink" title="使用Git在本地创建一个项目的过程"></a>使用Git在本地创建一个项目的过程</h4><pre><code>$ makdir ~/hello-world    //创建一个项目hello-world
$ cd ~/hello-world       //打开这个项目
$ git init             //初始化 
$ touch README
$ git add README        //更新README文件
$ git commit -m &apos;first commit&apos;     //提交更新，并注释信息“first commit” 
$ git remote add origin git@github.com:username/hello-world.git     //连接远程github项目  
$ git push -u origin master     //将本地项目更新到github项目上去
</code></pre><h4 id="使用Github创建的过程"><a href="#使用Github创建的过程" class="headerlink" title="使用Github创建的过程"></a>使用Github创建的过程</h4><pre><code>1、新建repo，copy git.io地址
2、$ git clone git.io地址
</code></pre><h4 id="删除本地仓库："><a href="#删除本地仓库：" class="headerlink" title="删除本地仓库："></a><em>删除本地仓库：</em></h4><pre><code>find . -name &quot;.git&quot; | xargs rm -Rf
</code></pre><h4 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h4><pre><code>git remote rm origin            //删除源origin
git pull origin master        //将github上的项目拉下来
git remote rm origin             //删除源origin
git pull origin master      //将github上的项目拉下来
git fetch origin          //获取远程更新
git merge origin/master //把更新合并
//pull=fetch+merge
git remote          //查看远程仓库
git branch          //查看当前分支
</code></pre><p><strong>about SSH</strong>：</p>
<p>创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p>
<pre><code>$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;
</code></pre><p><br></p>
<hr>
<p><strong><em>相关链接：</em></strong>    </p>
<ul>
<li><a href="http://my.oschina.net/xdev/blog/114383" target="_blank" rel="external">图解Git[强烈推荐]</a></li>
<li><a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="external">Git-简明指南[超简练]</a></li>
<li><a href="http://www.worldhello.net/gotgithub/" target="_blank" rel="external">GotGitHub[从零开始推荐]</a></li>
<li><a href="http://blog.csdn.net/dengjianqiang2011/article/details/9260435" target="_blank" rel="external">github常见操作和常见错误！</a></li>
<li><a href="http://862123204-qq-com.iteye.com/blog/1683315" target="_blank" rel="external">git push用法和常见问题分析</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[git push -u origin master 时出错]]></title>
      <url>http://yoursite.com/2016/08/01/git-push-u-origin-master-%E6%97%B6%E5%87%BA%E9%94%99/</url>
      <content type="html"><![CDATA[<p><strong>git push -u origin master时出错：</strong></p>
<pre><code>$ git push -u origin master
To git@github.com:******/Demo.git
 ! [rejected]        master -&gt; master (non-fast-forward)
error: failed to push some refs to &apos;git@github.com:username/xxx.git&apos;
hint: Updates were rejected because the tip of your current branch is behind
hint: its remote counterpart. Merge the remote changes (e.g. &apos;git pull&apos;)
hint: before pushing again.
hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details.
</code></pre><p>远程repository和本地的repository冲突导致的，而我在创建版本库后，在github的版本库页面点击了创建README.md文件的按钮创建了说明文档，但是却没有pull到本地。这样就产生了版本冲突的问题。</p>
<p>有如下几种解决方法：</p>
<p>1.强制push</p>
<pre><code>$ git push -u origin master -f 
</code></pre><p>这样会使远程修改丢失，一般是不可取的，尤其是多人协作开发的时候。</p>
<p>2.push前先将远程repository修改pull下来</p>
<pre><code>$ git pull origin master
$ git push -u origin master
</code></pre><p>3.若不想merge远程和本地修改，可以先创建新的分支：</p>
<pre><code>$ git branch [name]
</code></pre><p>然后push</p>
<pre><code>$ git push -u origin [name]
</code></pre>]]></content>
    </entry>
    
  
  
</search>
