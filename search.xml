<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[testimg]]></title>
      <url>http://yoursite.com/2017/03/05/testimg/</url>
      <content type="html"><![CDATA[<p><div><img src="http://rogerdudler.github.io/git-guide/img/trees.png" style=""></div><div><img src="http://rogerdudler.github.io/git-guide/img/trees.png" style=""></div><div><img src="http://rogerdudler.github.io/git-guide/img/trees.png" style=""></div><div><img src="http://rogerdudler.github.io/git-guide/img/trees.png" style=""></div><div><img src="http://rogerdudler.github.io/git-guide/img/trees.png" style=""></div><br><a id="more"></a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[谜之js]]></title>
      <url>http://yoursite.com/2016/09/02/%E8%B0%9C%E4%B9%8Bjs/</url>
      <content type="html"><![CDATA[<h3 id="Firstly"><a href="#Firstly" class="headerlink" title="Firstly"></a>Firstly</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><h5 id="几种常用方法："><a href="#几种常用方法：" class="headerlink" title="几种常用方法："></a>几种常用方法：</h5><ul>
<li><strong><em>indexOf( )</em></strong> 来搜索一个指定的元素的位置</li>
<li><p><strong><em>slice( )</em></strong>就是对应String的<strong><em>substring( )</em></strong>版本，它截取Array的部分元素，然后返回一个新的Array。</p>
<ul>
<li><p>注意到slice( )的起止参数包括开始索引，不包括结束索引。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>];</div><div class="line">arr.slice(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']</span></div><div class="line">arr.slice(<span class="number">3</span>); <span class="comment">// 从索引3开始到结束: ['D', 'E', 'F', 'G']</span></div></pre></td></tr></table></figure>
</li>
<li><p>如果不给slice( )传递任何参数，它就会从头到尾截取所有元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>];</div><div class="line"><span class="keyword">var</span> aCopy = arr.slice();</div><div class="line">aCopy; <span class="comment">// ['A', 'B', 'C', 'D', 'E', 'F', 'G']</span></div><div class="line">aCopy === arr; <span class="comment">// false</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong><em>push( )</em></strong>向Array的末尾添加若干元素，<strong><em>pop( )</em></strong>则把Array的最后一个元素删除掉：</li>
<li>如果要往Array的头部添加若干元素，使用<strong><em>unshift( )</em></strong>方法，<strong><em>shift( )</em></strong>方法则把Array的第一个元素删掉</li>
<li><p><strong><em>splice()</em></strong>方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素</p>
<pre><code>arr.splice(2, 3, &apos;Google&apos;, &apos;Facebook&apos;);//从索引2开始删除三个元素并添加两个元素
</code></pre></li>
<li><strong><em>join( )</em></strong>方法把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串</li>
</ul>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><ul>
<li>如果我们要检测xiaoming是否拥有某一属性，可以用<strong><em>in</em></strong>操作符：’name’ in xiaoming;</li>
<li>不过要小心，如果in判断一个属性存在，这个属性不一定是xiaoming的，它可能是xiaoming继承得到的：要判断一个属性是否是xiaoming自身拥有的，而不是继承得到的，可以用<strong><em>hasOwnProperty(‘name’)</em></strong>方法：</li>
</ul>
<h4 id="Map和Set"><a href="#Map和Set" class="headerlink" title="Map和Set"></a>Map和Set</h4><p>JavaScript的默认对象表示方式{}可以视为其他语言中的Map或Dictionary的数据结构，即一组键值对。但是JavaScript的对象有个小问题，就是键必须是字符串。但实际上Number或者其他数据类型作为键也是非常合理的。</p>
<ul>
<li><p>为了解决这个问题，最新的ES6规范引入了新的数据类型Map</p>
<pre><code>var m = new Map([[&apos;Michael&apos;, 95], [&apos;Bob&apos;, 75], [&apos;Tracy&apos;, 85]]);
m.get(&apos;Michael&apos;); // 95
m.set(&apos;Adam&apos;, 67); // 添加新的key-value
</code></pre></li>
<li><p>Set和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set：</p>
<pre><code>var s1 = new Set(); // 空Set
var s2 = new Set([1, 2, 3]); // 含1, 2, 3
//重复元素在Set中自动被过滤
</code></pre></li>
</ul>
<h4 id="iterable"><a href="#iterable" class="headerlink" title="iterable"></a>iterable</h4><p>遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。具有iterable类型的集合可以通过新的<strong><em>for … of</em></strong>循环来遍历。(for … of循环是ES6引入的新的语法)</p>
<h5 id="for-…-of循环和for-…-in循环有何区别？"><a href="#for-…-of循环和for-…-in循环有何区别？" class="headerlink" title="for … of循环和for … in循环有何区别？"></a>for … of循环和for … in循环有何区别？</h5><p>for … of循环只循环集合本身的元素 in还遍历继承来的属性</p>
<h5 id="forEach方法"><a href="#forEach方法" class="headerlink" title="forEach方法"></a>forEach方法</h5><p>更好的方法是<strong><em>forEach方法</em></strong>，它接收一个函数，每次迭代就自动回调该函数。以Array为例：</p>
<pre><code>var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];
a.forEach(function (element, index, array) {
    // element: 指向当前元素的值
    // index: 指向当前索引
    // array: 指向Array对象本身
    alert(element);
});
</code></pre><p>Set与Array类似，但Set没有索引，因此回调函数的前两个参数都是元素本身：</p>
<pre><code>var s = new Set([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]);
s.forEach(function (element, sameElement, set) {
    alert(element);
});
</code></pre><p>Map的回调函数参数依次为value、key和map本身：</p>
<pre><code>var m = new Map([[1, &apos;x&apos;], [2, &apos;y&apos;], [3, &apos;z&apos;]]);
m.forEach(function (value, key, map) {
    alert(value);
});
</code></pre><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h4><p>JavaScript还有一个免费赠送的关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array：</p>
<pre><code>function foo(x) {
    alert(x); // 10
    for (var i=0; i&lt;arguments.length; i++) {
        alert(arguments[i]); // 10, 20, 30
    }
}
foo(10, 20, 30);
</code></pre><p>arguments最常用于判断传入参数的个数。你可能会看到这样的写法：</p>
<pre><code>// foo(a[, b], c)
// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：
function foo(a, b, c) {
    if (arguments.length === 2) {
        // 实际拿到的参数是a和b，c为undefined
            c = b; // 把b赋给c
        b = null; // b变为默认值
    }
    // ...
}
</code></pre><h4 id="rest"><a href="#rest" class="headerlink" title="rest"></a>rest</h4><p>要把中间的参数b变为“可选”参数，就只能通过arguments判断，然后重新调整参数并赋值。<br>ES6标准引入了rest参数，上面的函数可以改写为：</p>
<pre><code>function foo(a, b, ...rest) {
    console.log(&apos;a = &apos; + a);
    console.log(&apos;b = &apos; + b);
    console.log(rest);
}

foo(1, 2, 3, 4, 5);
// 结果:
// a = 1
// b = 2
// Array [ 3, 4, 5 ]

foo(1);
// 结果:
// a = 1
// b = undefined
// Array []
</code></pre><ul>
<li><p>rest参数只能写在最后，前面用…标识，从运行结果可知，传入的参数先绑定a、b，多余的参数以数组形式交给变量rest，所以，不再需要arguments我们就获取了全部参数。</p>
</li>
<li><p>如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个空数组（注意不是undefined）。</p>
</li>
</ul>
<h4 id="名字空间"><a href="#名字空间" class="headerlink" title="名字空间"></a>名字空间</h4><p>全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。</p>
<p>减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如：</p>
<pre><code>// 唯一的全局变量MYAPP:
var MYAPP = {};

// 其他变量:
MYAPP.name = &apos;myapp&apos;;
MYAPP.version = 1.0;

// 其他函数:
MYAPP.foo = function () {
    return &apos;foo&apos;;
};
</code></pre><h4 id="apply-call"><a href="#apply-call" class="headerlink" title="apply call"></a>apply call</h4><p>要指定函数的this指向哪个对象，可以用函数本身的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。</p>
<p>用apply修复getAge()调用：</p>
<pre><code>function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}

var xiaoming = {
    name: &apos;小明&apos;,
    birth: 1990,
    age: getAge
};

xiaoming.age(); // 25
getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空
</code></pre><p>另一个与apply()类似的方法是call()，唯一区别是：</p>
<p>apply()把参数打包成Array再传入；</p>
<p>call()把参数按顺序传入。</p>
<p>比如调用Math.max(3, 5, 4)，分别用apply()和call()实现如下：</p>
<p>Math.max.apply(null, [3, 5, 4]); // 5<br>Math.max.call(null, 3, 5, 4); // 5<br>对普通函数调用，我们通常把this绑定为null。</p>
<h4 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h4><p>利用apply()，我们还可以动态改变函数的行为。</p>
<p>JavaScript的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。</p>
<p>现在假定我们想统计一下代码一共调用了多少次parseInt()，可以把所有的调用都找出来，然后手动加上count += 1，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的parseInt()：</p>
<pre><code>var count = 0;
var oldParseInt = parseInt; // 保存原函数

window.parseInt = function () {
    count += 1;
    return oldParseInt.apply(null, arguments); // 调用原函数
};

// 测试:
parseInt(&apos;10&apos;);
parseInt(&apos;20&apos;);
parseInt(&apos;30&apos;);
count; // 3
</code></pre><h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><p>把函数作为参数传到另一个函数</p>
<pre><code>function add(x, y, f) {
return f(x) + f(y);
}
</code></pre><h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><p>map方法定义在Array中，参数是函数，对数组每一项执行函数。</p>
<p>所以，map()作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数，比如，把Array的所有数字转为字符串：</p>
<pre><code>var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
arr.map(String); // [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;]
</code></pre><p>只需要一行代码。</p>
<h5 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h5><p>比方说对一个Array求和，就可以用reduce实现：</p>
<pre><code>var arr = [1, 3, 5, 7, 9];
arr.reduce(function (x, y) {
    return x + y;
}); // 25
</code></pre><p>要把[1, 3, 5, 7, 9]变换成整数13579，reduce()也能派上用场：</p>
<pre><code>var arr = [1, 3, 5, 7, 9];
arr.reduce(function (x, y) {
    return x * 10 + y;
}); // 13579
</code></pre><p>如果我们继续改进这个例子，想办法把一个字符串13579先变成Array——[1, 3, 5, 7, 9]，再利用reduce()就可以写出一个把字符串转换为Number的函数。</p>
<p>练习：不要使用JavaScript内置的parseInt()函数，利用map和reduce操作实现一个string2int()函数：</p>
<pre><code>&apos;use strict&apos;;

function string2int(s) {
    var arr = s.split();

    return arr.map(function (x){return +x;}).reduce(function (x,y){return x*10+y;})
}
</code></pre><p>练习</p>
<p>请把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：[‘adam’, ‘LISA’, ‘barT’]，输出：[‘Adam’, ‘Lisa’, ‘Bart’]。</p>
<pre><code>&apos;use strict&apos;;

function normalize(arr) {
    return arr.map(function (x){var tail = x.substring(1).toLowerCase();var head = x[0].toUpperCase();return head + tail;})
｝
</code></pre><p>练习</p>
<p>利用map()把字符串变成整数</p>
<pre><code>&apos;use strict&apos;;

var arr = [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;];
var r;

r = arr.map(r = arr.map(function (x){return +x;}););

alert(&apos;[&apos; + r[0] + &apos;, &apos; + r[1] + &apos;, &apos; + r[2] + &apos;]&apos;);
</code></pre><h5 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h5><p>参数也是函数，把函数作用于每个元素，根据return true还是false来决定保留还是丢弃元素</p>
<h5 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h5><p>sort按照ascii码进行排序，但sort()方法也是一个高阶函数，也可以接收一个比较函数来实现自定义的排序。！</p>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>在面向对象的程序设计语言里，比如Java和C++，要在对象内部封装一个私有变量，可以用private修饰一个成员变量。</p>
<p>在没有class机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。我们用JavaScript创建一个计数器：</p>
<pre><code>&apos;use strict&apos;;

function create_counter(initial) {
    var x = initial || 0;
    return {
        inc: function () {
            x += 1;
            return x;
        }
    }
}
</code></pre><p>它用起来像这样：</p>
<pre><code>var c1 = create_counter();
c1.inc(); // 1
c1.inc(); // 2
c1.inc(); // 3

var c2 = create_counter(10);
c2.inc(); // 11
c2.inc(); // 12
c2.inc(); // 13    
</code></pre><p>在返回的对象中，实现了一个闭包，该闭包携带了局部变量x，并且，从外部代码根本无法访问到变量x。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。</p>
<p>闭包还可以把多参数的函数变成单参数的函数。例如，要计算xy可以用Math.pow(x, y)函数，不过考虑到经常计算x2或x3，我们可以利用闭包创建新的函数pow2和pow3：</p>
<pre><code>function make_pow(n) {
    return function (x) {
        return Math.pow(x, n);
    }
}

// 创建两个新函数:
var pow2 = make_pow(2);
var pow3 = make_pow(3);

pow2(5); // 25
pow3(7); // 343
</code></pre><p>定义运算</p>
<pre><code>&apos;use strict&apos;;

// 定义数字0:
var zero = function (f) {
    return function (x) {
        return x;
    }
};

// 定义数字1:
var one = function (f) {
    return function (x) {
        return f(x);
    }
};

// 定义加法:
function add(n, m) {
    return function (f) {
        return function (x) {
            return m(f)(n(f)(x));
        }
    }
}    
</code></pre><p><em>参见维基百科<a href="https://zh.wikipedia.org/wiki/%CE%9B%E6%BC%94%E7%AE%97" target="_blank" rel="external">λ演算</a></em></p>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p><em>ES6新增函数 Arrow Function</em></p>
<pre><code>x =&gt; x * x
</code></pre><p>上面的箭头函数相当于一个匿名函数：</p>
<pre><code>function (x) {
    return x * x;
}
</code></pre><ul>
<li>=&gt;前代表参数：如果有多个参数，用括号括起来(x,y)=&gt;</li>
<li>如果要返回一个对象，x =&gt; ({ foo: x })，要和函数体本身的｛…｝区分开</li>
</ul>
<p><em>箭头函数与匿名函数的区别：箭头函数内部的this是词法作用域，也就是外层调用者obj，由上下文确定</em></p>
<p><em>由于this在箭头函数中已经按照词法作用域绑定了，所以，用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略</em></p>
<h4 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h4><p>generator（生成器）是ES6标准引入的新的数据类型。一个generator看上去像一个函数，但可以返回多次。</p>
<p>直接调用一个generator和调用函数不一样，fib(5)仅仅是创建了一个generator对象，还没有去执行它。</p>
<p>调用generator对象有两个方法，一是不断地调用generator对象的<strong><em>next()</em></strong>方法：</p>
<pre><code>var f = fib(5);
f.next(); // {value: 0, done: false}
f.next(); // {value: 1, done: false}
f.next(); // {value: 1, done: false}
f.next(); // {value: 2, done: false}
f.next(); // {value: 3, done: true}
</code></pre><p>next()方法会执行generator的代码，然后，每次遇到yield x;就返回一个对象{value: x, done: true/false}，然后“暂停”。返回的value就是yield的返回值，done表示这个generator是否已经执行结束了。如果done为true，则value就是return的返回值。</p>
<p>当执行到done为true时，这个generator对象就已经全部执行完毕，不要再继续调用next()了。</p>
<p>第二个方法是直接用<strong><em>for … of</em></strong>循环迭代generator对象，这种方式不需要我们自己判断done：</p>
<pre><code>for (var x of fib(5)) {
    console.log(x); // 依次输出0, 1, 1, 2, 3
}
</code></pre><h3 id="标准对象"><a href="#标准对象" class="headerlink" title="标准对象"></a>标准对象</h3><ul>
<li><p>不要使用new Number()、new Boolean()、new String()创建包装对象；</p>
</li>
<li><p>用parseInt()或parseFloat()来转换任意类型到number；</p>
</li>
<li><p>用String()来转换任意类型到string，或者直接调用某个对象的toString()方法；</p>
</li>
<li><p>通常不必把任意类型转换为boolean再判断，因为可以直接写if (myVar) {…}；</p>
</li>
<li><p>typeof操作符可以判断出number、boolean、string、function和undefined；</p>
</li>
<li><p>判断Array要使用Array.isArray(arr)；</p>
</li>
<li><p>判断null请使用myVar === null；</p>
</li>
<li><p>判断某个全局变量是否存在用typeof window.myVar === ‘undefined’；</p>
</li>
<li><p>函数内部判断某个变量是否存在用typeof myVar === ‘undefined’。</p>
</li>
<li><p>number对象调用toString()报SyntaxError：</p>
<pre><code>123.toString(); // SyntaxError
</code></pre><p>遇到这种情况，要特殊处理一下：</p>
<pre><code>123..toString(); // &apos;123&apos;, 注意是两个点！
(123).toString(); // &apos;123&apos;
</code></pre></li>
</ul>
<h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><pre><code>var now = new Date();
now; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)
now.getFullYear(); // 2015, 年份
now.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月
now.getDate(); // 24, 表示24号
now.getDay(); // 3, 表示星期三
now.getHours(); // 19, 24小时制
now.getMinutes(); // 49, 分钟
now.getSeconds(); // 22, 秒
now.getMilliseconds(); // 875, 毫秒数
now.getTime(); // 1435146562875, 以number形式表示的时间戳
</code></pre><p><em>ps:getmouth()从0-11</em></p>
<h4 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h4><p>用*表示任意个字符（包括0个），用+表示至少一个字符，用?表示0个或1个字符，用{n}表示n个字符，用{n,m}表示n-m个字符</p>
<h5 id="创建正则表达式："><a href="#创建正则表达式：" class="headerlink" title="创建正则表达式："></a>创建正则表达式：</h5><ol>
<li>/…/</li>
<li>new RegExp(‘…’)</li>
</ol>
<p>两种写法是一样的：</p>
<pre><code>var re1 = /ABC\-001/;
var re2 = new RegExp(&apos;ABC\\-001&apos;);

re1; // /ABC\-001/
re2; // /ABC\-001/
</code></pre><p>注意，如果使用第二种写法，因为字符串的转义问题，字符串的两个\实际上是一个\。</p>
<p>先看看如何判断正则表达式是否匹配：</p>
<pre><code>var re = /^\d{3}\-\d{3,8}$/;
re.test(&apos;010-12345&apos;); // true
re.test(&apos;010-1234x&apos;); // false
re.test(&apos;010 12345&apos;); // false
</code></pre><p>RegExp对象的test()方法用于测试给定的字符串是否符合条件。</p>
<h5 id="提取子串：exec"><a href="#提取子串：exec" class="headerlink" title="提取子串：exec();"></a>提取子串：exec();</h5><pre><code>var re = /^(\d{3})-(\d{3,8})$/;
re.exec(&apos;010-12345&apos;); // [&apos;010-12345&apos;, &apos;010&apos;, &apos;12345&apos;]
re.exec(&apos;010 12345&apos;); // null
</code></pre><ul>
<li>exec()方法在匹配成功后，会返回一个Array，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。</li>
<li><p>exec()方法在匹配失败时返回null。</p>
<h5 id="贪婪匹配"><a href="#贪婪匹配" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h5><p>正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0：</p>
<pre><code>var re = /^(\d+)(0*)$/;
re.exec(&apos;102300&apos;); // [&apos;102300&apos;, &apos;102300&apos;, &apos;&apos;]
</code></pre><p>由于\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。</p>
</li>
</ul>
<p>必须让\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\d+采用非贪婪匹配：</p>
<pre><code>var re = /^(\d+?)(0*)$/;
re.exec(&apos;102300&apos;); // [&apos;102300&apos;, &apos;1023&apos;, &apos;00&apos;]
</code></pre><h5 id="全局搜索"><a href="#全局搜索" class="headerlink" title="全局搜索"></a>全局搜索</h5><p>g：全局搜索</p>
<pre><code>var r1 = /test/g;
// 等价于:
var r2 = new RegExp(&apos;test&apos;, &apos;g&apos;);
</code></pre><p>全局匹配可以多次执行exec()方法来搜索一个匹配的字符串。当我们指定g标志后，每次运行exec()，正则表达式本身会更新lastIndex属性，表示上次匹配到的最后索引</p>
<p>i：忽略大小写</p>
<p>m：执行多行匹配</p>
<pre><code>var re =  /^\w+\.?\w+@\w+\.(com|org)/;
//正则的｛｝里表示匹配次数
//()表示的就是要提取的分组（Group）
var re = /^(\d{3})-(\d{3,8})$/;
</code></pre><h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p>JavaScript Object Notation</p>
<p>JSON是一种数据交换格式，很多高级语言内置了JSON库。<br>1.序列化（把JavaScript对象变成JSON）</p>
<pre><code>//首先定义一个对象xiaoming
var xiaoming{
    name:&apos;小明&apos;，
    age:13,
    gender:true,
    height:1.40,
    grade: null,
    &apos;middle-school&apos;: &apos;\&quot;W3C\&quot; Middle School&apos;,
    skills: [&apos;JavaScript&apos;, &apos;Java&apos;, &apos;Python&apos;, &apos;Lisp&apos;]

};
//然后序列化该对象
JSON.stringify(xiaoming);
//产生整齐一点的JSON字符串可以这样写：
JSON.stringify(xiaoming,null,&apos;  &apos;);
//第二个参数可以用一个数组/函数代替。以此产生用户所需的JSON字符串。
</code></pre><p>2.反序列化，就是把JSON格式的字符串变成一个JS对象。</p>
<pre><code>JSON.parse(&apos;{&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;：14}&apos;,function(key,value){
    if(key===&apos;name&apos;){
      return value+&apos;同学&apos;;
    }
    return value;
});
</code></pre><h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><p>创建原型的方法</p>
<pre><code>var Student = {
    name: &apos;Robot&apos;,
    height: 1.2,
    run: function () {
        console.log(this.name + &apos; is running...&apos;);
    }
};

var xiaoming = {
    name: &apos;小明&apos;
};

xiaoming.__proto__ = Student;
</code></pre><p>但是，由于低版本的IE也无法使用<strong>proto</strong>。Object.create()方法可以传入一个原型对象，并创建一个基于该原型的新对象，但是新对象什么属性都没有，因此，我们可以编写一个函数来创建xiaoming：</p>
<pre><code>function createStudent(name) {
    // 基于Student原型创建一个新对象:
    var s = Object.create(Student);
    // 初始化新对象:
    s.name = name;
    return s;
}

var xiaoming = createStudent(&apos;小明&apos;);
xiaoming.run(); // 小明 is running...
xiaoming.__proto__ === Student; // true
</code></pre><p>####创建对象＊important<br>除了直接用{ … }创建一个对象外，JavaScript还可以用一种构造函数的方法来创建对象。它的用法是，先定义一个构造函数：</p>
<pre><code>function Student(name) {
    this.name = name;
    this.hello = function () {
        alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);
    }
}
</code></pre><p>你会问，咦，这不是一个普通函数吗？</p>
<p>这确实是一个普通函数，但是在JavaScript中，可以用关键字new来调用这个函数，并返回一个对象：</p>
<pre><code>var xiaoming = new Student(&apos;小明&apos;);
xiaoming.name; // &apos;小明&apos;
xiaoming.hello(); // Hello, 小明!
</code></pre><p>注意，如果不写new，这就是一个普通函数，它返回undefined。但是，如果写了new，它就变成了一个构造函数，它绑定的this指向新创建的对象，并默认返回this，也就是说，不需要在最后写return this;。</p>
<p>新创建的xiaoming的原型链是：</p>
<pre><code>xiaoming ----&gt; Student.prototype ----&gt; Object.prototype ----&gt; null
</code></pre><p>prototype／constructor</p>
<p>用new Student()创建的对象还从原型上获得了一个constructor属性，它指向函数Student本身：</p>
<pre><code>xiaoming.constructor === Student.prototype.constructor; // true
Student.prototype.constructor === Student; // true

Object.getPrototypeOf(xiaoming) === Student.prototype; // true

xiaoming instanceof Student; // true
</code></pre><p><img src="http://www.liaoxuefeng.com/files/attachments/00143529922671163eebb527bc14547ac11363bf186557d000/l" alt="原型链"></p>
<h4 id="原型继承＊＊important"><a href="#原型继承＊＊important" class="headerlink" title="原型继承＊＊important"></a>原型继承＊＊important</h4><pre><code>// PrimaryStudent构造函数:
function PrimaryStudent(props) {
    Student.call(this, props);
    this.grade = props.grade || 1;
}

// 空函数F:
function F() {
}

// 把F的原型指向Student.prototype:
F.prototype = Student.prototype;

// 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype:
PrimaryStudent.prototype = new F();

// 把PrimaryStudent原型的构造函数修复为PrimaryStudent:
PrimaryStudent.prototype.constructor = PrimaryStudent;

// 继续在PrimaryStudent原型（就是new F()对象）上定义方法：
PrimaryStudent.prototype.getGrade = function () {
    return this.grade;
};

// 创建xiaoming:
var xiaoming = new PrimaryStudent({
    name: &apos;小明&apos;,
    grade: 2
});
xiaoming.name; // &apos;小明&apos;
xiaoming.grade; // 2

// 验证原型:
xiaoming.__proto__ === PrimaryStudent.prototype; // true
xiaoming.__proto__.__proto__ === Student.prototype; // true

// 验证继承关系:
xiaoming instanceof PrimaryStudent; // true
xiaoming instanceof Student; // true
</code></pre><p><img src="http://www.liaoxuefeng.com/files/attachments/001439872160923ca15925ec79f4692a98404ddb2ed5503000/l" alt="图解"></p>
<p>注意，函数F仅用于桥接，我们仅创建了一个new F()实例，而且，没有改变原有的Student定义的原型链。</p>
<p>如果把继承这个动作用一个inherits()函数封装起来，还可以隐藏F的定义，并简化代码：</p>
<pre><code>function inherits(Child, Parent) {
    var F = function () {};
    F.prototype = Parent.prototype;
    Child.prototype = new F();
    Child.prototype.constructor = Child;
}
</code></pre><p>这个inherits()函数可以复用：</p>
<pre><code>function Student(props) {
    this.name = props.name || &apos;Unnamed&apos;;
}

Student.prototype.hello = function () {
    alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);
}

function PrimaryStudent(props) {
    Student.call(this, props);
    this.grade = props.grade || 1;
}

// 实现原型继承链:
inherits(PrimaryStudent, Student);

// 绑定其他方法到PrimaryStudent原型:
PrimaryStudent.prototype.getGrade = function () {
    return this.grade;
};
</code></pre><p>JavaScript的原型继承实现方式就是：</p>
<ol>
<li><p>定义新的构造函数，并在内部用call()调用希望“继承”的构造函数，并绑定this；</p>
</li>
<li><p>借助中间函数F实现原型链继承，最好通过封装的inherits函数完成；</p>
</li>
<li><p>继续在新的构造函数的原型上定义新方法。</p>
</li>
</ol>
<h4 id="class继承"><a href="#class继承" class="headerlink" title="class继承"></a>class继承</h4><p>class从ES6开始正式被引入到JavaScript中。class的目的就是让定义类更简单。</p>
<pre><code>class Student {
    constructor(name) {
        this.name = name;
    }

    hello() {
        alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);
    }
}

//调用
var xiaoming = new Student(&apos;小明&apos;);
xiaoming.hello();

//继承
class PrimaryStudent extends Student {
    constructor(name, grade) {
        super(name); // 记得用super调用父类的构造方法!
        this.grade = grade;
    }

    myGrade() {
        alert(&apos;I am at grade &apos; + this.grade);
    }
}
</code></pre><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><h4 id="浏览器对象"><a href="#浏览器对象" class="headerlink" title="浏览器对象"></a>浏览器对象</h4><ul>
<li><p>window</p>
</li>
<li><p>navigator</p>
<pre><code>alert(&apos;appName = &apos; + navigator.appName + &apos;\n&apos; +
    &apos;appVersion = &apos; + navigator.appVersion + &apos;\n&apos; +
    &apos;language = &apos; + navigator.language + &apos;\n&apos; +
    &apos;platform = &apos; + navigator.platform + &apos;\n&apos; +
    &apos;userAgent = &apos; + navigator.userAgent);
</code></pre><p><strong><em>请注意</em></strong>，navigator的信息可以很容易地被用户修改，所以JavaScript读取的值不一定是正确的。很多初学者为了针对不同浏览器编写不同的代码，喜欢用if判断浏览器版本，例如：</p>
<pre><code>var width;
if (getIEVersion(navigator.userAgent) &lt; 9) {
    width = document.body.clientWidth;
} else {
    width = window.innerWidth;
}
</code></pre><p>但这样既可能判断不准确，也很难维护代码。正确的方法是充分利用JavaScript对不存在属性返回undefined的特性，直接用短路运算符||计算：</p>
<pre><code>var width = window.innerWidth || document.body.clientWidth;
</code></pre></li>
<li><p>screen</p>
<pre><code>screen.width：屏幕宽度，以像素为单位；
screen.height：屏幕高度，以像素为单位；
screen.colorDepth：返回颜色位数，如8、16、24。
</code></pre></li>
<li><p>location</p>
<pre><code>location.protocol; // &apos;http&apos;
location.host; // &apos;www.example.com&apos;
location.port; // &apos;8080&apos;
location.pathname; // &apos;/path/index.html&apos;
location.search; // &apos;?a=1&amp;b=2&apos;
location.hash; // &apos;TOP&apos;
location.assign(&apos;&apos;);//加载一个新页面
location.reload();//重新加载当前页面
</code></pre></li>
<li><p>document</p>
<ul>
<li>document.getElementById()</li>
<li>document.getElementsByTagName()</li>
<li><p>document.cookie; // ‘v=123; remember=true; prefer=zh’</p>
<p>  <em>Cookie是由服务器发送的key-value标示符。因为HTTP协议是无状态的，但是服务器要区分到底是哪个用户发过来的请求，就可以用Cookie来区分。当一个用户成功登录后，服务器发送一个Cookie给浏览器，例如user=ABC123XYZ(加密的字符串)…，此后，浏览器访问该网站时，会在请求头附上这个Cookie，服务器根据Cookie即可区分出用户。<br>Cookie还可以存储网站的一些设置，例如，页面显示的语言等等。</em></p>
<p>JavaScript可以通过document.cookie读取到当前页面的Cookie：</p>
<p>  document.cookie; // ‘v=123; remember=true; prefer=zh’<br>由于JavaScript能读取到页面的Cookie，而用户的登录信息通常也存在Cookie中，这就造成了巨大的安全隐患，这是因为在HTML页面中引入第三方的JavaScript代码是允许的：</p>
  <!-- 当前页面在wwwexample.com -->
<p>  <html></html></p>
<pre><code>&lt;head&gt;
    &lt;script src=&quot;http://www.foo.com/jquery.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
...
</code></pre><p>  <br>如果引入的第三方的JavaScript中存在恶意代码，则www.foo.com网站将直接获取到www.example.com网站的用户登录信息。</p>
<p>为了解决这个问题，服务器在设置Cookie时可以使用httpOnly，设定了httpOnly的Cookie将不能被JavaScript读取。这个行为由浏览器实现，主流浏览器均支持httpOnly选项，IE从IE6 SP1开始支持。</p>
<p>为了确保安全，服务器端在设置Cookie时，应该始终坚持使用httpOnly。</p>
</li>
</ul>
</li>
<li><p>history</p>
<p>   任何时候都不建议用</p>
</li>
</ul>
<h4 id="操作dom两种方法：document-get和queryselector"><a href="#操作dom两种方法：document-get和queryselector" class="headerlink" title="操作dom两种方法：document.get和queryselector"></a>操作dom两种方法：document.get和queryselector</h4><p>方法一</p>
<pre><code>// 返回ID为&apos;test&apos;的节点：
var test = document.getElementById(&apos;test&apos;);

// 先定位ID为&apos;test-table&apos;的节点，再返回其内部所有tr节点：
var trs = document.getElementById(&apos;test-table&apos;).getElementsByTagName(&apos;tr&apos;);

// 先定位ID为&apos;test-div&apos;的节点，再返回其内部所有class包含red的节点：
var reds = document.getElementById(&apos;test-div&apos;).getElementsByClassName(&apos;red&apos;);

// 获取节点test下的所有直属子节点:
var cs = test.children;

// 获取节点test下第一个、最后一个子节点：
var first = test.firstElementChild;
var last = test.lastElementChild;
</code></pre><p>方法二</p>
<pre><code>// 通过querySelector获取ID为q1的节点：
var q1 = document.querySelector(&apos;#q1&apos;);

// 通过querySelectorAll获取q1节点内的符合条件的所有节点：
var ps = q1.querySelectorAll(&apos;div.highlighted &gt; p&apos;);
</code></pre><h5 id="更新dom"><a href="#更新dom" class="headerlink" title="更新dom"></a>更新dom</h5><ul>
<li><p>修改innerhtml属性，要注意对字符编码来避免XSS攻击</p>
</li>
<li><p>修改innertext和innercontent属性，确保无法设置html标签</p>
</li>
<li><p>修改css（DOM节点的style属性对应所有的CSS，可以直接获取或设置。因为CSS允许font-size这样的名称，但它并非JavaScript有效的属性名，所以需要在JavaScript中改写为驼峰式命名fontSize）</p>
<pre><code>// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p&gt;
var p = document.getElementById(&apos;p-id&apos;);
// 设置CSS:
p.style.color = &apos;#ff0000&apos;;
p.style.fontSize = &apos;20px&apos;;
p.style.paddingTop = &apos;2em&apos;;
</code></pre></li>
</ul>
<h5 id="插入dom"><a href="#插入dom" class="headerlink" title="插入dom"></a>插入dom</h5><p>appendChild</p>
<pre><code>var d = document.createElement(&apos;style&apos;);
d.setAttribute(&apos;type&apos;, &apos;text/css&apos;);
d.innerHTML = &apos;p { color: red }&apos;;
document.getElementsByTagName(&apos;head&apos;)[0].appendChild(d);
</code></pre><p>insertBefore</p>
<p>parentElement.insertBefore(newElement, referenceElement);，子节点会插入到referenceElement之前。</p>
<p>假定我们要把Haskell插入到Python之前：</p>
<pre><code>&lt;!-- HTML结构 --&gt;
&lt;div id=&quot;list&quot;&gt;
    &lt;p id=&quot;java&quot;&gt;Java&lt;/p&gt;
    &lt;p id=&quot;python&quot;&gt;Python&lt;/p&gt;
    &lt;p id=&quot;scheme&quot;&gt;Scheme&lt;/p&gt;
&lt;/div&gt;
</code></pre><p>可以这么写：</p>
<pre><code>var
    list = document.getElementById(&apos;list&apos;),
    ref = document.getElementById(&apos;python&apos;),
    haskell = document.createElement(&apos;p&apos;);
haskell.id = &apos;haskell&apos;;
haskell.innerText = &apos;Haskell&apos;;
list.insertBefore(haskell, ref);
</code></pre><h5 id="删除dom"><a href="#删除dom" class="headerlink" title="删除dom"></a>删除dom</h5><p>先获得父节点，然后removechild</p>
<pre><code>// 拿到待删除节点:
var self = document.getElementById(&apos;to-be-removed&apos;);
// 拿到父节点:
var parent = self.parentElement;
// 删除:
var removed = parent.removeChild(self);
removed === self; // true
</code></pre><p><em>注意到删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置。</em></p>
<p>当你遍历一个父节点的子节点并进行删除操作时，要注意，children属性是一个只读属性，并且它在子节点变化时会实时更新。</p>
<h4 id="操作表单"><a href="#操作表单" class="headerlink" title="操作表单"></a>操作表单</h4><p>HTML5新增了大量标准控件，常用的包括date、datetime、datetime-local、color等，它们都使用\<input>标签：</p>
<pre><code>&lt;input type=&quot;date&quot; value=&quot;2015-07-01&quot;&gt;
&lt;input type=&quot;datetime-local&quot; value=&quot;2015-07-01T02:03:04&quot;&gt;
&lt;input type=&quot;color&quot; value=&quot;#ff0000&quot;&gt;
</code></pre><p>提交表单：</p>
<ul>
<li><form>的submit（）方法<br><br>      <form id="test-form"><br>          <input type="text" name="test"><br>          <button type="button" onclick="doSubmitForm()">Submit</button><br>      </form>

<pre><code>&lt;script&gt;
function doSubmitForm() {
    var form = document.getElementById(&apos;test-form&apos;);
    // 可以在此修改form的input...
    // 提交form:
    form.submit();
}
&lt;/script&gt;
</code></pre></form></li>
<li><p>响应<form>本身的onsubmit事件，在提交form时作修改：</form></p>
<pre><code>&lt;form id=&quot;test-form&quot; onsubmit=&quot;return checkForm()&quot;&gt;
    &lt;input type=&quot;text&quot; name=&quot;test&quot;&gt;
    &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;
&lt;/form&gt;

&lt;script&gt;
function checkForm() {
    var form = document.getElementById(&apos;test-form&apos;);
    // 可以在此修改form的input...
    // 继续下一步:
    return true;
}
&lt;/script&gt; 
</code></pre></li>
</ul>
<p><strong><em>密码MD5加密</em></strong></p>
<pre><code>&lt;!-- HTML --&gt;
&lt;form id=&quot;login-form&quot; method=&quot;post&quot; onsubmit=&quot;return checkForm()&quot;&gt;
    &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot;&gt;
    &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot;&gt;
    &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;
&lt;/form&gt;

&lt;script&gt;
function checkForm() {
    var pwd = document.getElementById(&apos;password&apos;);
    // 把用户输入的明文变为MD5:
    pwd.value = toMD5(pwd.value);
    // 继续下一步:
    return true;
}
&lt;/script&gt;
</code></pre><p>这个做法看上去没啥问题，但用户输入了口令提交时，口令框的显示会突然从几个<em>变成32个</em>（因为MD5有32个字符）。</p>
<p>要想不改变用户的输入，可以利用<input type="hidden">实现：</p>
<pre><code>&lt;!-- HTML --&gt;
&lt;form id=&quot;login-form&quot; method=&quot;post&quot; onsubmit=&quot;return checkForm()&quot;&gt;
    &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot;&gt;
    &lt;input type=&quot;password&quot; id=&quot;input-password&quot;&gt;
    &lt;input type=&quot;hidden&quot; id=&quot;md5-password&quot; name=&quot;password&quot;&gt;
    &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;
&lt;/form&gt;

&lt;script&gt;
function checkForm() {
    var input_pwd = document.getElementById(&apos;input-password&apos;);
    var md5_pwd = document.getElementById(&apos;md5-password&apos;);
    // 把用户输入的明文变为MD5:
    md5_pwd.value = toMD5(input_pwd.value);
    // 继续下一步:
    return true;
}
&lt;/script&gt;
</code></pre><h4 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h4><p>在HTML表单中，可以上传文件的唯一控件就是\<input type="file">。</p>
<p>注意：当一个表单包含\<input type="file">时，表单的enctype必须指定为multipart/form-data，method必须指定为post，浏览器才能正确编码并以multipart/form-data格式发送表单的数据。</p>
<p>出于安全考虑，浏览器只允许用户点击\<input type="file">来选择本地文件，用JavaScript对\<input type="file">的value赋值是没有任何效果的。当用户选择了上传某个文件后，JavaScript也无法获得该文件的真实路径</p>
<p>但是js可以在提交表单时对文件扩展名做检查</p>
<pre><code>var f = document.getElementById(&apos;test-file-upload&apos;);
var filename = f.value; // &apos;C:\fakepath\test.png&apos;
if (!filename || !(filename.endsWith(&apos;.jpg&apos;) || filename.endsWith(&apos;.png&apos;) || filename.endsWith(&apos;.gif&apos;))) {
    alert(&apos;Can only upload image file.&apos;);
    return false;
}
</code></pre><p>HTML5的File API提供了File和FileReader两个主要对象，可以获得文件信息并读取文件。</p>
<p>下面的例子演示了如何读取用户选取的图片文件，并在一个<div>中预览图像：</div></p>
<pre><code>var
    fileInput = document.getElementById(&apos;test-image-file&apos;),
    info = document.getElementById(&apos;test-file-info&apos;),
    preview = document.getElementById(&apos;test-image-preview&apos;);
// 监听change事件:
fileInput.addEventListener(&apos;change&apos;, function () {
    // 清除背景图片:
    preview.style.backgroundImage = &apos;&apos;;
    // 检查文件是否选择:
    if (!fileInput.value) {
        info.innerHTML = &apos;没有选择文件&apos;;
        return;
    }
    // 获取File引用:
    var file = fileInput.files[0];
    // 获取File信息:
    info.innerHTML = &apos;文件: &apos; + file.name + &apos;&lt;br&gt;&apos; +
                     &apos;大小: &apos; + file.size + &apos;&lt;br&gt;&apos; +
                     &apos;修改: &apos; + file.lastModifiedDate;
    if (file.type !== &apos;image/jpeg&apos; &amp;&amp; file.type !== &apos;image/png&apos; &amp;&amp; file.type !== &apos;image/gif&apos;) {
        alert(&apos;不是有效的图片文件!&apos;);
        return;
    }
    // 读取文件:
    var reader = new FileReader();
    reader.onload = function(e) {
        var
            data = e.target.result; // &apos;data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...&apos;            
        preview.style.backgroundImage = &apos;url(&apos; + data + &apos;)&apos;;
    };
    // 以DataURL的形式读取文件:
    reader.readAsDataURL(file);
});
</code></pre><p><strong><em>回调</em></strong></p>
<p>上面的代码还演示了JavaScript的一个重要的特性就是单线程执行模式。在JavaScript中，浏览器的JavaScript执行引擎在执行JavaScript代码时，总是以单线程模式执行，也就是说，任何时候，JavaScript代码都不可能同时有多于1个线程在执行。</p>
<p>你可能会问，单线程模式执行的JavaScript，如何处理多任务？</p>
<p>在JavaScript中，执行多任务实际上都是异步调用，比如上面的代码：</p>
<pre><code>reader.readAsDataURL(file);
</code></pre><p>就会发起一个异步操作来读取文件内容。因为是异步操作，所以我们在JavaScript代码中就不知道什么时候操作结束，因此需要先设置一个回调函数：</p>
<pre><code>reader.onload = function(e) {
    // 当文件读取完成后，自动调用此函数:
};
</code></pre><p>当文件读取完成后，JavaScript引擎将自动调用我们设置的回调函数。执行回调函数时，文件已经读取完毕，所以我们可以在回调函数内部安全地获得文件内容。</p>
<h4 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h4><p>AJAX请求是异步执行的，也就是说，要通过回调函数获得响应。</p>
<p>在现代浏览器上写AJAX主要依靠XMLHttpRequest对象：</p>
<pre><code>function success(text) {
    var textarea = document.getElementById(&apos;test-response-text&apos;);
    textarea.value = text;
}

function fail(code) {
    var textarea = document.getElementById(&apos;test-response-text&apos;);
    textarea.value = &apos;Error code: &apos; + code;
}

var request = new XMLHttpRequest(); // 新建XMLHttpRequest对象

request.onreadystatechange = function () { // 状态发生变化时，函数被回调
    if (request.readyState === 4) { // 成功完成
        // 判断响应结果:
        if (request.status === 200) {
            // 成功，通过responseText拿到响应的文本:
            return success(request.responseText);
        } else {
            // 失败，根据响应码判断失败原因:
            return fail(request.status);
        }
    } else {
        // HTTP请求还在继续...
    }
}

// 发送请求:
request.open(&apos;GET&apos;, &apos;/api/categories&apos;);
request.send();

alert(&apos;请求已发送，请等待响应...&apos;);
</code></pre><h5 id="CORS？？？"><a href="#CORS？？？" class="headerlink" title="CORS？？？"></a>CORS？？？</h5><h4 id="Promise？？？"><a href="#Promise？？？" class="headerlink" title="Promise？？？"></a>Promise？？？</h4><h4 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas*"></a>Canvas<em>*</em></h4><p>Canvas的坐标以左上角为原点，水平向右为X轴，垂直向下为Y轴，以像素为单位，所以每个点都是非负整数。</p>
<p><code>CanvasRenderingContext2D</code>对象有若干方法来</p>
<h5 id="绘制图形："><a href="#绘制图形：" class="headerlink" title="绘制图形："></a>绘制图形：</h5><pre><code>&apos;use strict&apos;;

var
    canvas = document.getElementById(&apos;test-shape-canvas&apos;),
    ctx = canvas.getContext(&apos;2d&apos;);
    ctx.clearRect(0, 0, 200, 200); // 擦除(0,0)位置大小为200x200的矩形，擦除的意思是把该区域变为透明
    ctx.fillStyle = &apos;#dddddd&apos;; // 设置颜色
    ctx.fillRect(10, 10, 130, 130); // 把(10,10)位置大小为130x130的矩形涂色
    // 利用Path绘制复杂路径:
    var path=new Path2D();
    path.arc(75, 75, 50, 0, Math.PI*2, true);
    path.moveTo(110,75);
    path.arc(75, 75, 35, 0, Math.PI, false);
    path.moveTo(65, 65);
    path.arc(60, 65, 5, 0, Math.PI*2, true);
    path.moveTo(95, 65);
    path.arc(90, 65, 5, 0, Math.PI*2, true);
    ctx.strokeStyle = &apos;#0000ff&apos;;
    ctx.stroke(path);
</code></pre><h5 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h5><p>绘制文本就是在指定的位置输出文本，可以设置文本的字体、样式、阴影等，与CSS完全一致：</p>
<pre><code>&apos;use strict&apos;;

var
    canvas = document.getElementById(&apos;test-text-canvas&apos;),
    ctx = canvas.getContext(&apos;2d&apos;);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.shadowOffsetX = 2;
    ctx.shadowOffsetY = 2;
    ctx.shadowBlur = 2;
    ctx.shadowColor = &apos;#666666&apos;;
    ctx.font = &apos;24px Arial&apos;;
    ctx.fillStyle = &apos;#333333&apos;;
    ctx.fillText(&apos;带阴影的文字&apos;, 20, 40);
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[我为什么要用Node.js?]]></title>
      <url>http://yoursite.com/2016/08/27/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8Node-js/</url>
      <content type="html"><![CDATA[<p><em>英文出处：<a href="https://www.toptal.com/nodejs/why-the-hell-would-i-use-node-js" target="_blank" rel="external">toptal</a>。</em></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>JavaScript 高涨的人气带来了很多变化，以至于如今使用其进行网络开发的形式也变得截然不同了。就如同在浏览器中一样，现在我们也可以在服务器上运行 JavaScript ，从前端跨越到后端，这样巨大的反差让人难以想象，因为仅仅在几年前 Javascript 还如同 Flash 或者 Java applet 那样嵌入网页在沙箱环境中运行。</p>
<p>在深入Node.js之前，你可能需要阅读和了解使用跨栈式JavaScript（JavaScript across the stack）带来的好处，它统一了编程语言和数据格式（JSON），让你能最佳地重用开发人员资源。由于这更多的是关于 JavaScript 的特点，这里就不过多讨论它。但它确实是一个让人在开发环节中使用 Notode 的关键的优点。</p>
<p>正如维基百科 所说：“Node.js 是谷歌 V8 引擎、libuv平台抽象层 以及主体使用 Javscript 编写的核心库三者集合的一个包装外壳。” 除此之外，值得注意的是，Node.js 的作者瑞恩·达尔 (Ryan Dahl) 的目标是创建具有实时推送能力的网站。在 Node.js 中，他给了开发者一个使用事件驱动来实现异步开发的优秀解决方案。（注：V8是谷歌开发的，目前公认最快的 Javascript 解析引擎，libuv 是一个开源的、为 Node 定制而生的跨平台的异步 IO 库。）</p>
<p>简而言之：Node.js 在实时的 Web应用上采用了基于 WebSocket 的推送技术。这意味着什么样的革命性？Well，在经过了20多年的基于无状态的请求-返机制的无状态交互之后，我们终于有了实时的，双向连接的web应用，客户端和服务器端都可以发起通信，能够自由地交换数据。与此形成鲜明对比的是传统的 web响应模式，客户端总是主动发起通信而服务端被动返回。此外，这些都是基于运行在标准80端口上的开放Web组件（HTML、CSS和JS）。</p>
<p>可能有人会说，我们已经使用 Flash 和 Java Applet 的形式很多年了——但实际上，这些方式只是使用网络将数据传递到客户端上的沙箱环境。他们都是隔离运行的，而且经常操作到需要额外的权限之类的非标准端口。</p>
<p>凭借其独特的优势，Node.js的现在已经在许多著名公司的产品中起到了关键作用。</p>
<p>在这篇文章中，我们不仅将讨论这些优势是如何实现的，而且也会讨论为什么你使用 Node.js 来替代一些经典的Web应用程序模型。</p>
<h2 id="Node-js-是如何工作的？"><a href="#Node-js-是如何工作的？" class="headerlink" title="Node.js 是如何工作的？"></a>Node.js 是如何工作的？</h2><p>Node.js 的主要思路是：使用非阻塞的，事件驱动的 I/O 操作来保持在处理跨平台 (across distributed devices) 数据密集型实时应用时的轻巧高效。这听起来有点绕口。</p>
<p>它的真正含义是，Node.js 不是一个即将主导Web开发的世界的银弹级的平台。相反，它是一个满足特别需求的平台。你肯定不会希望使用 Node.js 去做 CPU密集型操作。事实上，使用它进行繁重的计算等于摒弃 Node 几乎所有的优点。Node 真正的亮点在于建设高性能，高扩展性的互联网应用——因为它能够处理庞大的并且高吞吐量的并发连接。</p>
<p>它的工作原理是相当有趣的。传统的网络服务技术，是每个新增一个连接（请求）便生成一个新的线程，这个新的线程会占用系统内存，最终会占掉所有的可用内存。而 Node.js 仅仅只运行在一个单线程中，使用非阻塞的异步 I/O 调用，所有连接都由该线程处理，在 libuv 的加分下，可以允许其支持数万并发连接（全部挂在该线程的事件循环中）。</p>
<p><img src="http://jbcdn2.b0.upaiyun.com/2013/12/toptal-blog-1_B.png" alt="toptal-blog-1_B"></p>
<p>做一个简单的计算: 假设是普通的Web程序，新接入一个连接会占用 2M 的内存，在有 8GB RAM的系统上运行时, 算上线程之间上下文切换的成本，并发连接的最大理论值则为 4000 个。这是在传统 Web服务端技术下的处理情况。而 Node.js 则达到了约 1M 一个并发连接的拓展级别.</p>
<p>当然，在所有客户端的请求共享单一线程时也会有问题, 这也是一个编写 Node.js 应用的潜在缺陷. 首先, 大量的计算可能会使得 Node 的单线程暂时失去反应, 并导致所有的其他客户端的请求一直阻塞, 直到计算结束才恢复正常。 其次，开发人员需要非常小心，不要让一个 Exception 阻塞核心的事件循环，因为这将导致 Node.js 实例的终止（实际上就是程序崩溃）。（ 笔者注：如 PHP 中某个页面挂掉是不会影响网站运行的，但是 Nodejs 是一个线程一个线程来处理所有的链接，所以不论是计算卡了或者是被异常阻塞了都可能会影响到其他所有的链接。解决方案在稍后讨论。）</p>
<p>用来避免异常抛出时中断进程的方法是将异常使用回调传递出去（而不是抛出他们，就像在其他环境中一样）。即使一些未处理的异常阻塞了程序，依旧有多种应对的解决方案，而且也有很多可用于监视 Node 进程来执行必要的崩溃后恢复工作的策略和工具（虽然你将无法恢复用户的 Session ），最常见的是使用 Forever 模块，或者采用其他的外部系统工具如 upstart and monit。</p>
<h2 id="NPM-The-Node-Package-Manager"><a href="#NPM-The-Node-Package-Manager" class="headerlink" title="NPM: The Node Package Manager"></a>NPM: The Node Package Manager</h2><p>当我们讨论 Node.js 的时候，一个绝对不应该忽略地方就是默认内置的模块管理工具 —— NPM。 其灵感来源与 Ruby Gems（具有版本和依赖管理功能，可以通过在线资料库便捷安装可重用的组件的管理工具）。</p>
<p>一个完整的公用模块列表可以在 NPM 的网站上找到（<a href="https:://npmjs.org/" target="_blank" rel="external">https:://npmjs.org/</a>），或者通过使用与 Node.js 一同安装的 NPM CLI 工具放问到。该模块的生态系统向所有人开放，任何人都可以发布自己的模块，所有的模块都可以在 NPM 资料库中找到。你可以在 <a href="http://howtonode.org/introduction-to-npm" target="_blank" rel="external">http://howtonode.org/introduction-to-npm</a> 页面找到 NPM 的一个简要介绍（有点旧，但依旧能看）。</p>
<p>目前非常流行的一些 NPM 模块有：</p>
<ul>
<li><a href="http://expressjs.com/" target="_blank" rel="external">express</a> – Express.js,是一个简洁而灵活的 node.js Web应用框架, 并且已经是现在大多数 Node.js 应用的标准框架，你已经可以在很多 Node.js 的书籍中看到它了。</li>
<li><a href="https://github.com/senchalabs/connect#readme" target="_blank" rel="external">connect</a> – Connect 是一个 Node.js 的 HTTP 服务拓展框架，提供一个高性能的“插件”集合，以中间件闻名，是 Express 的基础部分之一。</li>
<li><a href="http://socket.io/" target="_blank" rel="external">socket.io</a> 和 <a href="https://github.com/sockjs" target="_blank" rel="external">sockjs</a> – 目前服务端最流行的两个 websocket 组件。</li>
<li><a href="http://jade-lang.com/" target="_blank" rel="external">Jade</a> – 流行的模板引擎之一，并且是 Express.js 的默认模板引擎。其灵感来源于 HAML。</li>
<li><a href="https://npmjs.org/package/mongodb" target="_blank" rel="external">mongo</a> 和 <a href="https://github.com/mafintosh/mongojs" target="_blank" rel="external">mongojs</a> – 封装了 MongoDB 的的各种 API，不过笔者平常工作用的是 <a href="http://mongoosejs.com/" target="_blank" rel="external">mongoose</a> 也很推荐。</li>
<li><a href="https://github.com/NodeRedis/node_redis" target="_blank" rel="external">redis</a> – Redis 的客户端函数库.</li>
<li><a href="https://npmjs.org/package/coffee-script" target="_blank" rel="external">coffee-script</a> – CoffeeScript 编译器，允许开发者使用 Coffee 来编写他们的 Node.js 程序。</li>
<li><a href="https://npmjs.org/package/underscore" target="_blank" rel="external">underscore</a> (<a href="https://lodash.com/" target="_blank" rel="external">lodash</a>, <a href="https://www.npmjs.com/package/lazy" target="_blank" rel="external">lazy</a>) – 最流行的 JavaScript 工具库 , 用于 Node.js 的封装包，以及两个采取略有不同的实现方法来获得更好性能的同行。</li>
<li><a href="https://www.npmjs.com/package/forever" target="_blank" rel="external">forever</a> – 可能是用来确保 node 脚本持续运行的最流行的工具。</li>
</ul>
<p>还有很多好的模块，这里就不一一列举了（希望没有冒犯到没列举的）。</p>
<h2 id="Node-js-应该用在什么地方"><a href="#Node-js-应该用在什么地方" class="headerlink" title="Node.js 应该用在什么地方"></a>Node.js 应该用在什么地方</h2><h3 id="聊天"><a href="#聊天" class="headerlink" title="聊天"></a>聊天</h3><p>聊天是最典型的多用户实时交互的应用。从 IRC 开始，有许多开源或者不开源的协议都运行在非标准端口上，而现在，使用 Node.js 则可以解决这些问题——在标准的80端口运行 WebSockets。</p>
<p>聊天应用程序是最能体现 Node.js 优点的例子：轻量级、高流量并且能良好的应对跨平台设备上运行密集型数据（虽然计算能力低）。同时，聊天也是一个非常值得学习的用例，因为它很简单，并且涵盖了目前为止一个典型的 Node.js 会用到的大部分解决方案。</p>
<p>让我们试着来描绘它如何工作。</p>
<p>在最简单的情况下，我们布置了一个聊天室在我们的网站上，用户可以在上面发消息，当然是一对多的形式。例如，假设总共有三个人连接到我们的网站上。</p>
<p>在服务端这边， 我们有一个使用 Express.js 搭建的简单站点，该站点实现了两件事 </p>
<ol>
<li>处理路径为 ‘/’ 的GET请求时，下发包括一个留言板以及一个发送信息的 ‘发送’ 按钮的页面 </li>
<li>一个监听客户端发送新消息的 websockets 服务。</li>
</ol>
<p>在客户端这边，我们有一个 HTML 页面，上面有个两个 js 方法，一个是用于触发事件的 “发送” 按钮，这会把把输入的消息通过 webscoket 发送，另一个方法是用 webscoket 在客户端上监听服务端来的推送（例如，其他用户发送的消息）。</p>
<p>当有一个客户端发送消息的时候，发生的事情是：</p>
<ol>
<li>浏览器上，点击发送按钮触发了 js 函数，将输入框中的文字通过 websocket 消息发送到服务器的 websocket 客户端（页面初始化加载的时候连接的）。</li>
<li>服务端的 websocket 组件收到 消息，然后通过广播方法转发到其他所有连接的客户端。</li>
<li>通过页面上运行的 websocket 客户端组件，所有的客户端都能收到这条推送的新消息。接着 js 处理函数可以把这个消息添加到文字框内。</li>
</ol>
<p> <img src="http://jbcdn2.b0.upaiyun.com/2013/12/toptal-blog-2_B.png" alt="img1"></p>
<p>这是一个最简单的例子。如果要更好的解决方案，你可以使用 Redis 数据库做一个简单的缓存。在一个更高级的解决方案中，你可能需要一个消息路由来专门处理消息队列，并且需要一个更强健的发送机制，比如发送的时候覆盖上暂时离线的用户或者为离线的注册用户存储尚未接收的消息等等。但是不论你做了怎么样的改进，Node.js 都将遵循一个基本原则：响应事件，处理多个并发连接，并保持流动性的用户体验。</p>
<h3 id="对象数据库接口（API-ON-TOP-OF-AN-OBJECT-DB）"><a href="#对象数据库接口（API-ON-TOP-OF-AN-OBJECT-DB）" class="headerlink" title="对象数据库接口（API ON TOP OF AN OBJECT DB）"></a>对象数据库接口（API ON TOP OF AN OBJECT DB）</h3><p>尽管，Node.js 确实非常擅长实时交互的应用，同时它也十分适合通过对象数据库（object DB）来查询数据（如 MongoDB）。以 JSON 格式存储的数据允许 Node.js 直接处理，不需要纠结数据转换和匹配的问题。</p>
<p>举个例子，如果你正在使用 Rails，你会将 JSON 数据转成 二进制的 model，当数据再被 Backbone.js, Angular.js 或者 jQuery AJAX 之类的调用又要转回 JSON。如果是 Nodejs 的话，你可以通过一个 REST API 简单的导出 JSON 对象以供客户端使用。另外，从数据库读写时候如果使用的是 MongoDB 的话，你也不用担心的 JSON 与任何数据之间的格式问题。总之，你可以避免多元的数据转换问题，不论是在客户端、服务端还是数据库。</p>
<h3 id="队列输入"><a href="#队列输入" class="headerlink" title="队列输入"></a>队列输入</h3><p>如果你正在接收一个高量并发的数据，你的数据库可能会成为你处理的瓶颈。正如上面的描述，Node.js 可以轻松的处理并发连接。 但是，由于数据库操作是一个阻塞的操作（在这种情况下），这就是麻烦的地方。Node.js的解决方案是，在数据真正的写入之前就承认客户端的数据是真实的。</p>
<p>用这种方法，在高负载的时候系统继续维持它的响应，这在当客户端不需要严格确认一个数据是否成功的被写入时特别有用。典型的例子包括：日志记录或者用户跟踪数据（user-tracking data）的记录，这会被分批处理并且在稍后才使用；同时也包括最终一致性（so, 常用于 NoSQL）可以接受，不需要立即反应的操作（例如 Facebook 上更新点赞的数目）。</p>
<p>数据通过某些缓存或者消息队列的基础组件（例如 RabbitMQ, ZeroMQ）进入队列，并且通过一个独立的数据库批量写入进程来一一消化，或者通过一个更高性能的计算密集型后端服务来进行处理。其他的语言/框架也可以实现相似的操作，但在相同的配置下是达不到 nodejs 的高吞吐量与高并发。</p>
<p><img src="http://jbcdn2.b0.upaiyun.com/2013/12/toptal-blog-3_B.png" alt="toptal-blog-3_B"></p>
<p>简单的说：使用 Node，你可以把数据库操作扔到一边并在稍后处理它们，假设他们成功了一样继续执行下去。（笔者注：在开发中通常的情况通常是，种耗时的操作通过回调函数来异步处理，主线程继续往下执行）</p>
<h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p>在较为传统的网络平台上，HTTP 的请求和响应更像是孤立的事件；然而事实上，他们都是数据流。这一观察结果在 Nodejs 上可以用来建立一些很酷的功能。因为数据通以流的形式接收，而我们可以在网站上在线处理正在上传中的文件。这样的话，就可以实现实时的音频和视频编码，以及在不同数据源之间进行代码（代理见下一段）。</p>
<p>（笔者注：Node 有代替如 apache 这样的 webserver 处理数据，所以开发者可以直接收到客户端一份一份上传的数据，并实时处理。上面这段话听起来有点抽象，不过各位可以简单的想象一下不需要开 YY 或者 QQ，打开网页就能进行语音视频的功能。）</p>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>Node.js 可以通过异步的方式处理大量的并发连接，所以很容易作为服务端的代理来使用。这在与不同响应时间的不同服务之间进行代理，或者是收集来自多个来源的数据时尤其有用。</p>
<p>举个例子：考虑一个服务器端的应用程序和第三方资源进行通信以更新自不同来源的数据，或者将服务端上的一些图像和视频资源存储到第三方云服务。</p>
<p>虽然专用代理服务器确实存在，但是如果你还没有专用的代理服务器，或者你需要一个本地开发的解决方案，那么使用 Node 来做代理可能是更好的选择。关于这个解决方案，我的意思是指当你在开发的时候，你可以使用Node.js的开发环境搭建一个服务来处理对资源和代理的请求，而在生产环境下，你可以使用专用的代理服务（比如nginx，HAProxy等）来处理这些交互。</p>
<h3 id="股票操盘手的仪表盘"><a href="#股票操盘手的仪表盘" class="headerlink" title="股票操盘手的仪表盘"></a>股票操盘手的仪表盘</h3><p>让我们继续讨论应用程序这块。实时网络的解决方案可以很轻松的实现证券交易软件——用于跟踪股票的价格，执行计算、做技术分析，同时生成报表。</p>
<p>使用一个实时的的基于网页的解决方案，将会允许操盘手轻松的切换工作软件以及工作地点。相信不久，我们或许会在 佛罗里达州、伊维萨岛又或者是巴厘岛的海滩上看到他们。</p>
<h3 id="应用监听仪盘表"><a href="#应用监听仪盘表" class="headerlink" title="应用监听仪盘表"></a>应用监听仪盘表</h3><p>另一种常见的用例中，使用 Node+Web+Socket 非常适合：跟踪网站访问者并且可视化实时它们之间的实时交互。 （如果你有兴趣，可以去看看 Hummingbird）</p>
<p>你可能需要采集用户的实时状态, 或者甚至当他们到达渠道中某个特定的点时, 打开一个交流频道， 通过有针对性的互动介绍移动到下一个阶段. （如果你感兴趣的话，推荐你看看 CANDDi）</p>
<p>想象一下，如果你知道你的访客的实时操作，并能够形象化地看到他们的交互，这将对你的业务带来多大的提升。随着实时的、双向 socket 通信的 Node.js ，现在你可以做到了。</p>
<h3 id="系统监控仪表"><a href="#系统监控仪表" class="headerlink" title="系统监控仪表"></a>系统监控仪表</h3><p>现在，让我们看看事情的基础设施方面。想象一下，比如，希望为其用户提供服务监控页面（例如，GitHub上的状态页）的 SaaS 运营商 。通过 Node.js 的事件循环，我们可以创建一个基于 Web 的功能强大的仪表板，以异步方式检查服务状态并且使用的 WebSockets 将数据推送到客户端。</p>
<p>内部（公司内部）和公共服务的状态都可以使用该项技术实现实时的上报。让我们把这一想法延伸的远一点，试着想象一个电信运营商中网络运营中心（NOC）的监控应用，云/网络/服务器运营商，或者一些金融机构，全都运行在这个由 Node.js 和 WebSocket 组成的应用上，而不是 Java 和/或 Java Applet。</p>
<p>注意：不要尝试使用 Node 打造硬实时系统（即，响应时间要求一致的系统）。 Erlang是可能是该类应用程序的更好的选择。</p>
<h2 id="什么地方可以使用-Node-js"><a href="#什么地方可以使用-Node-js" class="headerlink" title="什么地方可以使用 Node.js"></a>什么地方可以使用 Node.js</h2><h3 id="服务端-WEB-应用"><a href="#服务端-WEB-应用" class="headerlink" title="服务端 WEB 应用"></a>服务端 WEB 应用</h3><p>通过 Node.js 使用 Express.js 也可以用来创建服务端上的典型的网页应用。然而，虽然有可能，使用 Node.js 来进行请求+响应的形式来呈现 HTML 并不是最典型的用例。有人赞成也有人反对这一做法。这里有一些看法以供参考:</p>
<p><strong>优点：</strong></p>
<ul>
<li>如果你不需要进行 CPU密集型计算，你可以从头到尾甚至是数据库（比如 MongoDB）都使用 Javascript 来开发。这显著地减轻了开发工序（包括成本）。</li>
<li>对于一个使用 Node.js 作为服务端的单页应用或者 websocket 应用，爬虫可以收到一个完全 HTML 呈现的响应，这是更为SEO友好的。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>任何CPU密集型的计算都将阻碍 Node.js 的反应，所以使用多线程的平台是一个更好的方法。或者，您也可以尝试向外扩展的计算[*]。</li>
<li>Node.js 使用关系型数据库依旧十分痛苦（详细见下方）。拜托了，如果你想执行关系型数据操作，请考虑别的环境：Rails， Django 甚至 ASP.NET MVC 。。。。</li>
</ul>
<p><strong>另一种解决方案是，为这些CPU密集型的计算建立一个高度可扩展的MQ支持的环境与后端处理，以保持 Node 作为一个前台专员来异步处理客户端请求。</strong></p>
<h2 id="Node-js-不应该在什么地方使用"><a href="#Node-js-不应该在什么地方使用" class="headerlink" title="Node.js 不应该在什么地方使用"></a>Node.js 不应该在什么地方使用</h2><h3 id="使用关系型数据库的服务端-WEB-应用"><a href="#使用关系型数据库的服务端-WEB-应用" class="headerlink" title="使用关系型数据库的服务端 WEB 应用"></a>使用关系型数据库的服务端 WEB 应用</h3><p>对比 Node.js 上的 Express.js 和 Ruby on Rails，当你使用关系型数据库的时候请毫不犹豫的选择后者。</p>
<p>Node.js 的关系数据库工具仍处于早期阶段，目前还没有成熟到让人能够愉快地使用它。而与此同时，Rails天生自带了数据访问组件，连同DB schema迁移的支持工具和一些Gems（一语双关，一指这些如同珍宝的工具，二指ruby的gems程序包）。Rails和它的搭档框架们拥有非常成熟且被证明了的活动记录（Active Record）或数据映射（Data Mapper）的数据访问层的实现，而这些是当你在使用纯JavaScript来复制这些应用的时候会非常想要使用的东西。</p>
<p>不过，如果你真的倾向于全部使用 JS（并且做好可能抓狂的准备），那么请继续关注 Sequelize 和 Node ORM2 ，虽然这两者仍然不成熟的，但他们最终会迎头赶上。</p>
<p><strong>使用 Node 光是作为前端而 Rails 做后端来连接关系型数据库，这是完全有可能也并不少见的。（笔者注：国外有种说法，PHP这一类程序员也可以算作是前端）</strong></p>
<h3 id="繁重的服务端的计算和处理"><a href="#繁重的服务端的计算和处理" class="headerlink" title="繁重的服务端的计算和处理"></a>繁重的服务端的计算和处理</h3><p>当涉及到大量的计算，Node.js 就不是最佳的解决方案。你肯定不希望使用 Node.js 建立一个斐波那契数的计算服务。一般情况下，任何 CPU密集型操作 会削弱掉 Node通过事件驱动， 异步 I/O 模型等等带来的在吞吐量上的优势，因为当线程被非异步的高计算量占用时任何传入的请求将被阻塞。</p>
<p>正如前面所说，Node.js 是单线程的，只使用一个单一的CPU核心。至于，涉及到服务器上多核并发处理，Node 的核心团队已经使用 cluster 模块的形式在这一方面做了一些工作 (参考：<a href="http://nodejs.org/api/cluster.html)。当然，您也可以很容易的通过" target="_blank" rel="external">http://nodejs.org/api/cluster.html)。当然，您也可以很容易的通过</a> nginx 的反向代理运行多个 Node.js 的服务器实例来避免单一线程阻塞的问题。</p>
<p>关于集群(clustering) ，你应该将所有繁重的计算转移到更合适的语言写的后台进程来处理，同时让他们通过像 RabbitMQ 那样通过消息队列服务器来进行通信。</p>
<p>即使你的后台处理可能最初运行在同一台服务器上时看不出什么优点，但是这样的做法具有非常高的可扩展性的潜力。这些后台处理服务可以容易地分割出去，作为单独的 worker 服务器，而不需要配置入口 web服务器的负载。</p>
<p>当然，你也可以在其他语言平台上用同样的方法，但使用 Node.js 你可以得到很高的吞吐量，每个请求都作为一个小任务非常迅速和高效地处理，这一点我们已经讨论过了。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>我们已经从理论到实践讨论过 Node.js 了，从它的目标和野心，到其优点和缺点。在 Node.js 的开发中99%的问题是由误用阻塞操作而造成的。</p>
<p>请记住：Node.js 从来不是用于解决大规模计算问题而创建的。它的出现是为了解决大规模I/O 的问题，并且在这一点上做的非常好。</p>
<p>综上，如果你项目需求中不包含CPU密集型操作，也不需要访问任何阻塞的资源，那么你就可以利用的 Node.js 的优点，尽情的享受快速、可扩展的网络应用。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Virtualenv的使用]]></title>
      <url>http://yoursite.com/2016/08/02/virtualenv%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h3 id="我个人使用的目的：便于不同版本python开发"><a href="#我个人使用的目的：便于不同版本python开发" class="headerlink" title="我个人使用的目的：便于不同版本python开发"></a>我个人使用的目的：便于不同版本python开发</h3><h5 id="安装"><a href="#安装" class="headerlink" title="安装:"></a>安装:</h5><pre><code>$ sudo apt-get install python-virtualenv
</code></pre><h5 id="建存放目录："><a href="#建存放目录：" class="headerlink" title="建存放目录："></a>建存放目录：</h5><pre><code>$ mkdir testvirtual
</code></pre><h5 id="创建虚拟环境（python3下的）："><a href="#创建虚拟环境（python3下的）：" class="headerlink" title="创建虚拟环境（python3下的）："></a>创建虚拟环境（python3下的）：</h5><pre><code>$ virtualenv -p python3 env1
</code></pre><h5 id="启动虚拟环境："><a href="#启动虚拟环境：" class="headerlink" title="启动虚拟环境："></a>启动虚拟环境：</h5><pre><code>$ cd env1
$ source ./bin/activate
</code></pre><h5 id="退出虚拟环境："><a href="#退出虚拟环境：" class="headerlink" title="退出虚拟环境："></a>退出虚拟环境：</h5><pre><code>$ deactivate
</code></pre><h5 id="可以直接在虚拟环境运行pip等"><a href="#可以直接在虚拟环境运行pip等" class="headerlink" title="可以直接在虚拟环境运行pip等"></a>可以直接在虚拟环境运行pip等</h5><pre><code>$ pip install xxx
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Git整理]]></title>
      <url>http://yoursite.com/2016/08/01/Git%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<p><div><img src="http://rogerdudler.github.io/git-guide/img/trees.png" style=""></div></p>
<h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><a id="more"></a>
<p><strong>一、创建库</strong></p>
<pre><code>git init &lt;库名&gt;
</code></pre><p><strong>二、创建分支</strong> (打开刚创建的库: cd &lt;库名&gt;)</p>
<pre><code>git branch &lt;分支名&gt;
</code></pre><p>注：如果创建分支失败，建立一个测试文本文件即可。</p>
<pre><code>1. git add .
2. git commit -a -m &quot;test&quot;
</code></pre><p><strong>三、切换分支</strong></p>
<pre><code>git checkout &lt;分支名&gt; 
</code></pre><p>该语句和上一个语句可以和起来用一个语句表示：</p>
<pre><code>git checkout -b &lt;分支名&gt;
</code></pre><p><strong>四、查看当前库所有分支</strong></p>
<pre><code>git branch
</code></pre><p><strong>五、分支合并</strong></p>
<p>比如，如果要将当前的分支develop，合并到主分支master<br>首先我们需要切换到master主分支：</p>
<pre><code>git checkout master
</code></pre><p>然后执行合并操作：</p>
<pre><code>git merge develop
</code></pre><p>如果有冲突，会提示你，调用<code>git status</code>查看冲突文件。 </p>
<p>解决冲突，然后调用<code>git add</code>或<code>git rm</code>将解决后的文件暂存。 </p>
<p>所有冲突解决后，<code>git commit</code> 提交更改。</p>
<p><strong>六、分支衍合</strong></p>
<p>分支衍合和分支合并的差别在于，分支衍合不会保留合并的日志，不留痕迹，而 分支合并则会保留合并的日志。 </p>
<p>要将开发中的分支develop，衍合到主分支master<br>首先切换的master分支：</p>
<pre><code>git checkout master
</code></pre><p>然后执行衍和操作：</p>
<pre><code>git rebase develop
</code></pre><p>如果有冲突，会提示你，调用<code>git status</code>查看冲突文件。 </p>
<p>解决冲突，然后调用<code>git add</code>或<code>git rm</code>将解决后的文件暂存。<br>所有冲突解决后，</p>
<pre><code>git rebase –continue 
</code></pre><p>提交更改。</p>
<p><strong>七、删除分支</strong></p>
<pre><code>git branch -d &lt;分支名&gt; 
</code></pre><p>如果该分支没有合并到主分支会报错，可以用以下命令强制删除</p>
<pre><code>git branch -D &lt;分支名&gt;
</code></pre><p><strong>八、删除库</strong></p>
<pre><code>rm -rf &lt;库名&gt;
</code></pre><h3 id="创建项目站点-demo"><a href="#创建项目站点-demo" class="headerlink" title="创建项目站点(demo)"></a>创建项目站点(demo)</h3><pre><code>$ git clone https://github.com/USERNAME/PROJECT.git
$ git checkout --orphan gh-pages
$ git rm -rf .（可选，在里面放要展示的demo）
$ git add .
$ git commit -a -m &quot;First pages commit&quot;
$ git push origin gh-pages
$ 或者
$ git push -u origin HEAD
</code></pre><h4 id="使用Git在本地创建一个项目的过程"><a href="#使用Git在本地创建一个项目的过程" class="headerlink" title="使用Git在本地创建一个项目的过程"></a>使用Git在本地创建一个项目的过程</h4><pre><code>$ makdir ~/hello-world    //创建一个项目hello-world
$ cd ~/hello-world       //打开这个项目
$ git init             //初始化 
$ touch README
$ git add README        //更新README文件
$ git commit -m &apos;first commit&apos;     //提交更新，并注释信息“first commit” 
$ git remote add origin git@github.com:username/hello-world.git     //连接远程github项目  
$ git push -u origin master     //将本地项目更新到github项目上去
</code></pre><h4 id="使用Github创建的过程"><a href="#使用Github创建的过程" class="headerlink" title="使用Github创建的过程"></a>使用Github创建的过程</h4><pre><code>1、新建repo，copy git.io地址
2、$ git clone git.io地址
</code></pre><h4 id="删除本地仓库："><a href="#删除本地仓库：" class="headerlink" title="删除本地仓库："></a><em>删除本地仓库：</em></h4><pre><code>find . -name &quot;.git&quot; | xargs rm -Rf
</code></pre><h4 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h4><pre><code>git remote rm origin            //删除源origin
git pull origin master        //将github上的项目拉下来
git remote rm origin             //删除源origin
git pull origin master      //将github上的项目拉下来
git fetch origin          //获取远程更新
git merge origin/master //把更新合并
//pull=fetch+merge
git remote          //查看远程仓库
git branch          //查看当前分支
</code></pre><p><strong>about SSH</strong>：</p>
<p>创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p>
<pre><code>$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;
</code></pre><p><br></p>
<hr>
<p><strong><em>相关链接：</em></strong>    </p>
<ul>
<li><a href="http://my.oschina.net/xdev/blog/114383" target="_blank" rel="external">图解Git[强烈推荐]</a></li>
<li><a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="external">Git-简明指南[超简练]</a></li>
<li><a href="http://www.worldhello.net/gotgithub/" target="_blank" rel="external">GotGitHub[从零开始推荐]</a></li>
<li><a href="http://blog.csdn.net/dengjianqiang2011/article/details/9260435" target="_blank" rel="external">github常见操作和常见错误！</a></li>
<li><a href="http://862123204-qq-com.iteye.com/blog/1683315" target="_blank" rel="external">git push用法和常见问题分析</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[git push -u origin master 时出错]]></title>
      <url>http://yoursite.com/2016/08/01/git-push-u-origin-master-%E6%97%B6%E5%87%BA%E9%94%99/</url>
      <content type="html"><![CDATA[<p><strong>git push -u origin master时出错：</strong></p>
<pre><code>$ git push -u origin master
To git@github.com:******/Demo.git
 ! [rejected]        master -&gt; master (non-fast-forward)
error: failed to push some refs to &apos;git@github.com:username/xxx.git&apos;
hint: Updates were rejected because the tip of your current branch is behind
hint: its remote counterpart. Merge the remote changes (e.g. &apos;git pull&apos;)
hint: before pushing again.
hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details.
</code></pre><p>远程repository和本地的repository冲突导致的，而我在创建版本库后，在github的版本库页面点击了创建README.md文件的按钮创建了说明文档，但是却没有pull到本地。这样就产生了版本冲突的问题。</p>
<p>有如下几种解决方法：</p>
<p>1.强制push</p>
<pre><code>$ git push -u origin master -f 
</code></pre><p>这样会使远程修改丢失，一般是不可取的，尤其是多人协作开发的时候。</p>
<p>2.push前先将远程repository修改pull下来</p>
<pre><code>$ git pull origin master
$ git push -u origin master
</code></pre><p>3.若不想merge远程和本地修改，可以先创建新的分支：</p>
<pre><code>$ git branch [name]
</code></pre><p>然后push</p>
<pre><code>$ git push -u origin [name]
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://yoursite.com/2016/08/01/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
